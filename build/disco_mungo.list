
build/disco_mungo.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <_vectors>:
 8000000:	20000400 	.word	0x20000400
 8000004:	08000301 	.word	0x08000301
 8000008:	08000303 	.word	0x08000303
 800000c:	08001c41 	.word	0x08001c41
 8000010:	08000303 	.word	0x08000303
 8000014:	08000303 	.word	0x08000303
 8000018:	08000303 	.word	0x08000303
 800001c:	08000303 	.word	0x08000303
 8000020:	08000303 	.word	0x08000303
 8000024:	08000303 	.word	0x08000303
 8000028:	08000303 	.word	0x08000303
 800002c:	08001c51 	.word	0x08001c51
 8000030:	08000303 	.word	0x08000303
 8000034:	08000303 	.word	0x08000303
 8000038:	08000303 	.word	0x08000303
 800003c:	08000303 	.word	0x08000303
 8000040:	08000303 	.word	0x08000303
 8000044:	08000303 	.word	0x08000303
 8000048:	08000303 	.word	0x08000303
 800004c:	08000303 	.word	0x08000303
 8000050:	08000303 	.word	0x08000303
 8000054:	08000303 	.word	0x08000303
 8000058:	08000303 	.word	0x08000303
 800005c:	08000303 	.word	0x08000303
 8000060:	08000303 	.word	0x08000303
 8000064:	08000303 	.word	0x08000303
 8000068:	08000303 	.word	0x08000303
 800006c:	08002341 	.word	0x08002341
 8000070:	08002311 	.word	0x08002311
 8000074:	080022e1 	.word	0x080022e1
 8000078:	080022b1 	.word	0x080022b1
 800007c:	08002281 	.word	0x08002281
 8000080:	08002251 	.word	0x08002251
 8000084:	08002221 	.word	0x08002221
 8000088:	08000303 	.word	0x08000303
 800008c:	08000303 	.word	0x08000303
 8000090:	08000303 	.word	0x08000303
 8000094:	08000303 	.word	0x08000303
 8000098:	08000303 	.word	0x08000303
 800009c:	08000303 	.word	0x08000303
 80000a0:	08000303 	.word	0x08000303
 80000a4:	08000303 	.word	0x08000303
 80000a8:	08000303 	.word	0x08000303
 80000ac:	08000303 	.word	0x08000303
 80000b0:	08001fb1 	.word	0x08001fb1
 80000b4:	08000303 	.word	0x08000303
 80000b8:	08000303 	.word	0x08000303
 80000bc:	08000303 	.word	0x08000303
 80000c0:	08000303 	.word	0x08000303
 80000c4:	08000303 	.word	0x08000303
 80000c8:	08000303 	.word	0x08000303
 80000cc:	08000303 	.word	0x08000303
 80000d0:	08000303 	.word	0x08000303
 80000d4:	08001f91 	.word	0x08001f91
 80000d8:	08001f71 	.word	0x08001f71
 80000dc:	08000303 	.word	0x08000303
 80000e0:	08000303 	.word	0x08000303
 80000e4:	08000303 	.word	0x08000303
 80000e8:	08000303 	.word	0x08000303
 80000ec:	08000303 	.word	0x08000303
 80000f0:	08000303 	.word	0x08000303
 80000f4:	08000303 	.word	0x08000303
 80000f8:	08000303 	.word	0x08000303
 80000fc:	080021f1 	.word	0x080021f1
 8000100:	08000303 	.word	0x08000303
 8000104:	08000303 	.word	0x08000303
 8000108:	08000303 	.word	0x08000303
 800010c:	08000303 	.word	0x08000303
 8000110:	08000303 	.word	0x08000303
 8000114:	08000303 	.word	0x08000303
 8000118:	08000303 	.word	0x08000303
 800011c:	08000303 	.word	0x08000303
 8000120:	080021c1 	.word	0x080021c1
 8000124:	08002191 	.word	0x08002191
 8000128:	08002161 	.word	0x08002161
 800012c:	08002131 	.word	0x08002131
 8000130:	08002101 	.word	0x08002101
 8000134:	08000303 	.word	0x08000303
 8000138:	08000303 	.word	0x08000303
 800013c:	08000303 	.word	0x08000303
 8000140:	08000303 	.word	0x08000303
 8000144:	08000303 	.word	0x08000303
 8000148:	08000303 	.word	0x08000303
 800014c:	08000303 	.word	0x08000303
 8000150:	080020d1 	.word	0x080020d1
 8000154:	080020a1 	.word	0x080020a1
 8000158:	08002071 	.word	0x08002071
 800015c:	08000303 	.word	0x08000303
 8000160:	08000303 	.word	0x08000303
 8000164:	08000303 	.word	0x08000303
 8000168:	08000303 	.word	0x08000303
 800016c:	08000303 	.word	0x08000303
 8000170:	08000303 	.word	0x08000303
 8000174:	08000303 	.word	0x08000303
 8000178:	08000303 	.word	0x08000303
 800017c:	08000303 	.word	0x08000303
 8000180:	08000303 	.word	0x08000303
 8000184:	08000303 	.word	0x08000303
 8000188:	08000303 	.word	0x08000303
 800018c:	08000303 	.word	0x08000303
 8000190:	08000303 	.word	0x08000303
 8000194:	08000303 	.word	0x08000303
 8000198:	08000303 	.word	0x08000303
 800019c:	08000303 	.word	0x08000303
 80001a0:	08000303 	.word	0x08000303
 80001a4:	08000303 	.word	0x08000303
 80001a8:	08000303 	.word	0x08000303
 80001ac:	08000303 	.word	0x08000303
 80001b0:	08000303 	.word	0x08000303
 80001b4:	08000303 	.word	0x08000303
 80001b8:	08000303 	.word	0x08000303
 80001bc:	08000303 	.word	0x08000303
 80001c0:	08000303 	.word	0x08000303
 80001c4:	08000303 	.word	0x08000303
 80001c8:	08000303 	.word	0x08000303
 80001cc:	08000303 	.word	0x08000303
 80001d0:	08000303 	.word	0x08000303
 80001d4:	08000303 	.word	0x08000303
 80001d8:	08000303 	.word	0x08000303
 80001dc:	08000303 	.word	0x08000303

Disassembly of section .text:

080001e0 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 80001e0:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 80001e2:	4839      	ldr	r0, [pc, #228]	; (80002c8 <endfiniloop+0x6>)
                msr     MSP, r0
 80001e4:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80001e8:	4838      	ldr	r0, [pc, #224]	; (80002cc <endfiniloop+0xa>)
                msr     PSP, r0
 80001ea:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                ldr     r0, =_vectors
 80001ee:	4838      	ldr	r0, [pc, #224]	; (80002d0 <endfiniloop+0xe>)
                movw    r1, #SCB_VTOR & 0xFFFF
 80001f0:	f64e 5108 	movw	r1, #60680	; 0xed08
                movt    r1, #SCB_VTOR >> 16
 80001f4:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 80001f8:	6008      	str	r0, [r1, #0]
#endif

#if CRT0_INIT_FPU == TRUE
                /* FPU FPCCR initialization.*/
                movw    r0, #CRT0_FPCCR_INIT & 0xFFFF
 80001fa:	f240 0000 	movw	r0, #0
                movt    r0, #CRT0_FPCCR_INIT >> 16
 80001fe:	f2cc 0000 	movt	r0, #49152	; 0xc000
                movw    r1, #SCB_FPCCR & 0xFFFF
 8000202:	f64e 7134 	movw	r1, #61236	; 0xef34
                movt    r1, #SCB_FPCCR >> 16
 8000206:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 800020a:	6008      	str	r0, [r1, #0]
                dsb
 800020c:	f3bf 8f4f 	dsb	sy
                isb
 8000210:	f3bf 8f6f 	isb	sy

                /* CPACR initialization.*/
                movw    r0, #CRT0_CPACR_INIT & 0xFFFF
 8000214:	f240 0000 	movw	r0, #0
                movt    r0, #CRT0_CPACR_INIT >> 16
 8000218:	f2c0 00f0 	movt	r0, #240	; 0xf0
                movw    r1, #SCB_CPACR & 0xFFFF
 800021c:	f64e 5188 	movw	r1, #60808	; 0xed88
                movt    r1, #SCB_CPACR >> 16
 8000220:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 8000224:	6008      	str	r0, [r1, #0]
                dsb
 8000226:	f3bf 8f4f 	dsb	sy
                isb
 800022a:	f3bf 8f6f 	isb	sy

                /* FPU FPSCR initially cleared.*/
                mov     r0, #0
 800022e:	f04f 0000 	mov.w	r0, #0
                vmsr    FPSCR, r0
 8000232:	eee1 0a10 	vmsr	fpscr, r0

                /* FPU FPDSCR initially cleared.*/
                movw    r1, #SCB_FPDSCR & 0xFFFF
 8000236:	f64e 713c 	movw	r1, #61244	; 0xef3c
                movt    r1, #SCB_FPDSCR >> 16
 800023a:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 800023e:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA
 8000240:	2006      	movs	r0, #6
#else
                movs    r0, #CRT0_CONTROL_INIT
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 8000242:	f380 8814 	msr	CONTROL, r0
                isb
 8000246:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __core_init
 800024a:	f002 f8d9 	bl	8002400 <__core_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 800024e:	f001 fd57 	bl	8001d00 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 8000252:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 8000256:	491f      	ldr	r1, [pc, #124]	; (80002d4 <endfiniloop+0x12>)
                ldr     r2, =__main_stack_end__
 8000258:	4a1b      	ldr	r2, [pc, #108]	; (80002c8 <endfiniloop+0x6>)

0800025a <msloop>:
msloop:
                cmp     r1, r2
 800025a:	4291      	cmp	r1, r2
                itt     lo
 800025c:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800025e:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 8000262:	e7fa      	bcc.n	800025a <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 8000264:	491c      	ldr	r1, [pc, #112]	; (80002d8 <endfiniloop+0x16>)
                ldr     r2, =__process_stack_end__
 8000266:	4a19      	ldr	r2, [pc, #100]	; (80002cc <endfiniloop+0xa>)

08000268 <psloop>:
psloop:
                cmp     r1, r2
 8000268:	4291      	cmp	r1, r2
                itt     lo
 800026a:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800026c:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 8000270:	e7fa      	bcc.n	8000268 <psloop>
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =__textdata_base__
 8000272:	491a      	ldr	r1, [pc, #104]	; (80002dc <endfiniloop+0x1a>)
                ldr     r2, =__data_base__
 8000274:	4a1a      	ldr	r2, [pc, #104]	; (80002e0 <endfiniloop+0x1e>)
                ldr     r3, =__data_end__
 8000276:	4b1b      	ldr	r3, [pc, #108]	; (80002e4 <endfiniloop+0x22>)

08000278 <dloop>:
dloop:
                cmp     r2, r3
 8000278:	429a      	cmp	r2, r3
                ittt    lo
 800027a:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 800027c:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 8000280:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 8000284:	e7f8      	bcc.n	8000278 <dloop>
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
 8000286:	2000      	movs	r0, #0
                ldr     r1, =__bss_base__
 8000288:	4917      	ldr	r1, [pc, #92]	; (80002e8 <endfiniloop+0x26>)
                ldr     r2, =__bss_end__
 800028a:	4a18      	ldr	r2, [pc, #96]	; (80002ec <endfiniloop+0x2a>)

0800028c <bloop>:
bloop:
                cmp     r1, r2
 800028c:	4291      	cmp	r1, r2
                itt     lo
 800028e:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000290:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 8000294:	e7fa      	bcc.n	800028c <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 8000296:	f002 f86b 	bl	8002370 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 800029a:	f002 f8a9 	bl	80023f0 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_base__
 800029e:	4c14      	ldr	r4, [pc, #80]	; (80002f0 <endfiniloop+0x2e>)
                ldr     r5, =__init_array_end__
 80002a0:	4d14      	ldr	r5, [pc, #80]	; (80002f4 <endfiniloop+0x32>)

080002a2 <initloop>:
initloop:
                cmp     r4, r5
 80002a2:	42ac      	cmp	r4, r5
                bge     endinitloop
 80002a4:	da03      	bge.n	80002ae <endinitloop>
                ldr     r1, [r4], #4
 80002a6:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 80002aa:	4788      	blx	r1
                b       initloop
 80002ac:	e7f9      	b.n	80002a2 <initloop>

080002ae <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 80002ae:	f001 f9c7 	bl	8001640 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_base__
 80002b2:	4c11      	ldr	r4, [pc, #68]	; (80002f8 <endfiniloop+0x36>)
                ldr     r5, =__fini_array_end__
 80002b4:	4d11      	ldr	r5, [pc, #68]	; (80002fc <endfiniloop+0x3a>)

080002b6 <finiloop>:
finiloop:
                cmp     r4, r5
 80002b6:	42ac      	cmp	r4, r5
                bge     endfiniloop
 80002b8:	da03      	bge.n	80002c2 <endfiniloop>
                ldr     r1, [r4], #4
 80002ba:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 80002be:	4788      	blx	r1
                b       finiloop
 80002c0:	e7f9      	b.n	80002b6 <finiloop>

080002c2 <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 80002c2:	f002 b88d 	b.w	80023e0 <__default_exit>
 80002c6:	0000      	.short	0x0000
                ldr     r0, =__main_stack_end__
 80002c8:	20000400 	.word	0x20000400
                ldr     r0, =__process_stack_end__
 80002cc:	20000800 	.word	0x20000800
                ldr     r0, =_vectors
 80002d0:	08000000 	.word	0x08000000
                ldr     r1, =__main_stack_base__
 80002d4:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
 80002d8:	20000400 	.word	0x20000400
                ldr     r1, =__textdata_base__
 80002dc:	08002668 	.word	0x08002668
                ldr     r2, =__data_base__
 80002e0:	20000800 	.word	0x20000800
                ldr     r3, =__data_end__
 80002e4:	20000c00 	.word	0x20000c00
                ldr     r1, =__bss_base__
 80002e8:	20000c00 	.word	0x20000c00
                ldr     r2, =__bss_end__
 80002ec:	2001c9c0 	.word	0x2001c9c0
                ldr     r4, =__init_array_base__
 80002f0:	080001e0 	.word	0x080001e0
                ldr     r5, =__init_array_end__
 80002f4:	080001e0 	.word	0x080001e0
                ldr     r4, =__fini_array_base__
 80002f8:	080001e0 	.word	0x080001e0
                ldr     r5, =__fini_array_end__
 80002fc:	080001e0 	.word	0x080001e0

08000300 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 8000300:	e76e      	b.n	80001e0 <_crt0_entry>

08000302 <BusFault_Handler>:
        .thumb_func
Vector3F8:
        .thumb_func
Vector3FC:
#endif
        bl          _unhandled_exception
 8000302:	f000 f800 	bl	8000306 <_unhandled_exception>

08000306 <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 8000306:	e7fe      	b.n	8000306 <_unhandled_exception>

08000308 <_port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_switch
_port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 8000308:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if CORTEX_USE_FPU
                /* Saving FPU context.*/
                vpush   {s16-s31}
 800030c:	ed2d 8a10 	vpush	{s16-s31}
#if PORT_SWITCHED_REGIONS_NUMBER == 4
                push    {r4, r5, r6, r7, r8, r9, r10, r11}
#endif
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 8000310:	f8c1 d00c 	str.w	sp, [r1, #12]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 8000314:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 8000316:	469d      	mov	sp, r3
#endif
#endif

#if CORTEX_USE_FPU
                /* Restoring FPU context.*/
                vpop    {s16-s31}
 8000318:	ecbd 8a10 	vpop	{s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 800031c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08000320 <_port_thread_start>:
                bl      _stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 8000320:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 8000322:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 8000326:	4628      	mov	r0, r5
                blx     r4
 8000328:	47a0      	blx	r4
                movs    r0, #0              /* MSG_OK */
 800032a:	2000      	movs	r0, #0
                bl      chThdExit
 800032c:	f001 fca0 	bl	8001c70 <chThdExit>

08000330 <_zombies>:
_zombies:       b       _zombies
 8000330:	e7fe      	b.n	8000330 <_zombies>

08000332 <_port_switch_from_isr>:
                bl      _stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
#endif
                bl      chSchDoReschedule
 8000332:	f001 fcc5 	bl	8001cc0 <chSchDoReschedule>

08000336 <_port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 8000336:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 8000338:	e7fe      	b.n	8000338 <_port_exit_from_isr+0x2>
	...

0800033c <memcpy>:
 800033c:	4684      	mov	ip, r0
 800033e:	ea41 0300 	orr.w	r3, r1, r0
 8000342:	f013 0303 	ands.w	r3, r3, #3
 8000346:	d16d      	bne.n	8000424 <memcpy+0xe8>
 8000348:	3a40      	subs	r2, #64	; 0x40
 800034a:	d341      	bcc.n	80003d0 <memcpy+0x94>
 800034c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000350:	f840 3b04 	str.w	r3, [r0], #4
 8000354:	f851 3b04 	ldr.w	r3, [r1], #4
 8000358:	f840 3b04 	str.w	r3, [r0], #4
 800035c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000360:	f840 3b04 	str.w	r3, [r0], #4
 8000364:	f851 3b04 	ldr.w	r3, [r1], #4
 8000368:	f840 3b04 	str.w	r3, [r0], #4
 800036c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000370:	f840 3b04 	str.w	r3, [r0], #4
 8000374:	f851 3b04 	ldr.w	r3, [r1], #4
 8000378:	f840 3b04 	str.w	r3, [r0], #4
 800037c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000380:	f840 3b04 	str.w	r3, [r0], #4
 8000384:	f851 3b04 	ldr.w	r3, [r1], #4
 8000388:	f840 3b04 	str.w	r3, [r0], #4
 800038c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000390:	f840 3b04 	str.w	r3, [r0], #4
 8000394:	f851 3b04 	ldr.w	r3, [r1], #4
 8000398:	f840 3b04 	str.w	r3, [r0], #4
 800039c:	f851 3b04 	ldr.w	r3, [r1], #4
 80003a0:	f840 3b04 	str.w	r3, [r0], #4
 80003a4:	f851 3b04 	ldr.w	r3, [r1], #4
 80003a8:	f840 3b04 	str.w	r3, [r0], #4
 80003ac:	f851 3b04 	ldr.w	r3, [r1], #4
 80003b0:	f840 3b04 	str.w	r3, [r0], #4
 80003b4:	f851 3b04 	ldr.w	r3, [r1], #4
 80003b8:	f840 3b04 	str.w	r3, [r0], #4
 80003bc:	f851 3b04 	ldr.w	r3, [r1], #4
 80003c0:	f840 3b04 	str.w	r3, [r0], #4
 80003c4:	f851 3b04 	ldr.w	r3, [r1], #4
 80003c8:	f840 3b04 	str.w	r3, [r0], #4
 80003cc:	3a40      	subs	r2, #64	; 0x40
 80003ce:	d2bd      	bcs.n	800034c <memcpy+0x10>
 80003d0:	3230      	adds	r2, #48	; 0x30
 80003d2:	d311      	bcc.n	80003f8 <memcpy+0xbc>
 80003d4:	f851 3b04 	ldr.w	r3, [r1], #4
 80003d8:	f840 3b04 	str.w	r3, [r0], #4
 80003dc:	f851 3b04 	ldr.w	r3, [r1], #4
 80003e0:	f840 3b04 	str.w	r3, [r0], #4
 80003e4:	f851 3b04 	ldr.w	r3, [r1], #4
 80003e8:	f840 3b04 	str.w	r3, [r0], #4
 80003ec:	f851 3b04 	ldr.w	r3, [r1], #4
 80003f0:	f840 3b04 	str.w	r3, [r0], #4
 80003f4:	3a10      	subs	r2, #16
 80003f6:	d2ed      	bcs.n	80003d4 <memcpy+0x98>
 80003f8:	320c      	adds	r2, #12
 80003fa:	d305      	bcc.n	8000408 <memcpy+0xcc>
 80003fc:	f851 3b04 	ldr.w	r3, [r1], #4
 8000400:	f840 3b04 	str.w	r3, [r0], #4
 8000404:	3a04      	subs	r2, #4
 8000406:	d2f9      	bcs.n	80003fc <memcpy+0xc0>
 8000408:	3204      	adds	r2, #4
 800040a:	d008      	beq.n	800041e <memcpy+0xe2>
 800040c:	07d2      	lsls	r2, r2, #31
 800040e:	bf1c      	itt	ne
 8000410:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8000414:	f800 3b01 	strbne.w	r3, [r0], #1
 8000418:	d301      	bcc.n	800041e <memcpy+0xe2>
 800041a:	880b      	ldrh	r3, [r1, #0]
 800041c:	8003      	strh	r3, [r0, #0]
 800041e:	4660      	mov	r0, ip
 8000420:	4770      	bx	lr
 8000422:	bf00      	nop
 8000424:	2a08      	cmp	r2, #8
 8000426:	d313      	bcc.n	8000450 <memcpy+0x114>
 8000428:	078b      	lsls	r3, r1, #30
 800042a:	d08d      	beq.n	8000348 <memcpy+0xc>
 800042c:	f010 0303 	ands.w	r3, r0, #3
 8000430:	d08a      	beq.n	8000348 <memcpy+0xc>
 8000432:	f1c3 0304 	rsb	r3, r3, #4
 8000436:	1ad2      	subs	r2, r2, r3
 8000438:	07db      	lsls	r3, r3, #31
 800043a:	bf1c      	itt	ne
 800043c:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8000440:	f800 3b01 	strbne.w	r3, [r0], #1
 8000444:	d380      	bcc.n	8000348 <memcpy+0xc>
 8000446:	f831 3b02 	ldrh.w	r3, [r1], #2
 800044a:	f820 3b02 	strh.w	r3, [r0], #2
 800044e:	e77b      	b.n	8000348 <memcpy+0xc>
 8000450:	3a04      	subs	r2, #4
 8000452:	d3d9      	bcc.n	8000408 <memcpy+0xcc>
 8000454:	3a01      	subs	r2, #1
 8000456:	f811 3b01 	ldrb.w	r3, [r1], #1
 800045a:	f800 3b01 	strb.w	r3, [r0], #1
 800045e:	d2f9      	bcs.n	8000454 <memcpy+0x118>
 8000460:	780b      	ldrb	r3, [r1, #0]
 8000462:	7003      	strb	r3, [r0, #0]
 8000464:	784b      	ldrb	r3, [r1, #1]
 8000466:	7043      	strb	r3, [r0, #1]
 8000468:	788b      	ldrb	r3, [r1, #2]
 800046a:	7083      	strb	r3, [r0, #2]
 800046c:	4660      	mov	r0, ip
 800046e:	4770      	bx	lr

08000470 <sdObjectInit.constprop.0>:
 * @init
 */
#if !defined(SERIAL_ADVANCED_BUFFERING_SUPPORT) ||                          \
    (SERIAL_ADVANCED_BUFFERING_SUPPORT == FALSE) ||                         \
    defined(__DOXYGEN__)
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8000470:	b4f0      	push	{r4, r5, r6, r7}

  sdp->vmt = &vmt;
 8000472:	4603      	mov	r3, r0
 8000474:	4a12      	ldr	r2, [pc, #72]	; (80004c0 <sdObjectInit.constprop.0+0x50>)
 8000476:	f843 2b04 	str.w	r2, [r3], #4
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 800047a:	2201      	movs	r2, #1
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 800047c:	2500      	movs	r5, #0
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 800047e:	2710      	movs	r7, #16
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 8000480:	f100 0674 	add.w	r6, r0, #116	; 0x74
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 8000484:	f100 040c 	add.w	r4, r0, #12
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
 8000488:	6043      	str	r3, [r0, #4]
  oqp->q_notify  = onfy;
 800048a:	64c1      	str	r1, [r0, #76]	; 0x4c
  iqp->q_top     = bp + size;
 800048c:	f100 0364 	add.w	r3, r0, #100	; 0x64
  sdp->state = SD_STOP;
 8000490:	7202      	strb	r2, [r0, #8]
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 8000492:	f100 0130 	add.w	r1, r0, #48	; 0x30
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 8000496:	f100 0254 	add.w	r2, r0, #84	; 0x54
  iqp->q_counter = 0;
 800049a:	6145      	str	r5, [r0, #20]
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
  tqp->prev = (thread_t *)tqp;
 800049c:	e9c0 4403 	strd	r4, r4, [r0, #12]
  iqp->q_notify  = infy;
 80004a0:	6285      	str	r5, [r0, #40]	; 0x28
  oqp->q_counter = size;
 80004a2:	6387      	str	r7, [r0, #56]	; 0x38
  oqp->q_top     = bp + size;
 80004a4:	6406      	str	r6, [r0, #64]	; 0x40
  iqp->q_wrptr   = bp;
 80004a6:	e9c0 2208 	strd	r2, r2, [r0, #32]
}
 80004aa:	bcf0      	pop	{r4, r5, r6, r7}
  oqp->q_wrptr   = bp;
 80004ac:	e9c0 3311 	strd	r3, r3, [r0, #68]	; 0x44
 80004b0:	e9c0 110c 	strd	r1, r1, [r0, #48]	; 0x30
  iqp->q_link    = link;
 80004b4:	62c0      	str	r0, [r0, #44]	; 0x2c
  oqp->q_link    = link;
 80004b6:	6500      	str	r0, [r0, #80]	; 0x50
  iqp->q_buffer  = bp;
 80004b8:	6182      	str	r2, [r0, #24]
  iqp->q_top     = bp + size;
 80004ba:	61c3      	str	r3, [r0, #28]
  oqp->q_buffer  = bp;
 80004bc:	63c3      	str	r3, [r0, #60]	; 0x3c
 80004be:	4770      	bx	lr
 80004c0:	08002640 	.word	0x08002640
	...

080004d0 <i2s_lld_start_exchange.constprop.0>:
 * @param[in] i2sp      pointer to the @p I2SDriver object
 *
 * @notapi
 */
void i2s_lld_start_exchange(I2SDriver *i2sp) {
  size_t size = i2sp->config->size;
 80004d0:	4b16      	ldr	r3, [pc, #88]	; (800052c <i2s_lld_start_exchange.constprop.0+0x5c>)
 80004d2:	6858      	ldr	r0, [r3, #4]
     00 (16)  1 (32)  16
     01 (24)  X       32
     10 (32)  X       32
     11 (NA)  X       NA
     */
  if ((i2sp->config->i2scfgr & SPI_I2SCFGR_DATLEN) != 0)
 80004d4:	8a02      	ldrh	r2, [r0, #16]
 80004d6:	f002 0206 	and.w	r2, r2, #6
void i2s_lld_start_exchange(I2SDriver *i2sp) {
 80004da:	b470      	push	{r4, r5, r6}
  size_t size = i2sp->config->size;
 80004dc:	6884      	ldr	r4, [r0, #8]
  if ((i2sp->config->i2scfgr & SPI_I2SCFGR_DATLEN) != 0)
 80004de:	b102      	cbz	r2, 80004e2 <i2s_lld_start_exchange.constprop.0+0x12>
    size *= 2;
 80004e0:	0064      	lsls	r4, r4, #1

  /* RX DMA setup.*/
  if (NULL != i2sp->dmarx) {
 80004e2:	691a      	ldr	r2, [r3, #16]
    dmaStreamSetMode(i2sp->dmarx, i2sp->rxdmamode);
    dmaStreamSetPeripheral(i2sp->dmarx, &i2sp->spi->DR);
 80004e4:	6899      	ldr	r1, [r3, #8]
  if (NULL != i2sp->dmarx) {
 80004e6:	b162      	cbz	r2, 8000502 <i2s_lld_start_exchange.constprop.0+0x32>
    dmaStreamSetMode(i2sp->dmarx, i2sp->rxdmamode);
 80004e8:	6812      	ldr	r2, [r2, #0]
 80004ea:	699e      	ldr	r6, [r3, #24]
    dmaStreamSetMemory0(i2sp->dmarx, i2sp->config->rx_buffer);
 80004ec:	6845      	ldr	r5, [r0, #4]
    dmaStreamSetMode(i2sp->dmarx, i2sp->rxdmamode);
 80004ee:	6016      	str	r6, [r2, #0]
    dmaStreamSetPeripheral(i2sp->dmarx, &i2sp->spi->DR);
 80004f0:	f101 060c 	add.w	r6, r1, #12
 80004f4:	6096      	str	r6, [r2, #8]
    dmaStreamSetMemory0(i2sp->dmarx, i2sp->config->rx_buffer);
 80004f6:	60d5      	str	r5, [r2, #12]
    dmaStreamSetTransactionSize(i2sp->dmarx, size);
 80004f8:	6054      	str	r4, [r2, #4]
    dmaStreamEnable(i2sp->dmarx);
 80004fa:	6815      	ldr	r5, [r2, #0]
 80004fc:	f045 0501 	orr.w	r5, r5, #1
 8000500:	6015      	str	r5, [r2, #0]
  }

  /* TX DMA setup.*/
  if (NULL != i2sp->dmatx) {
 8000502:	695a      	ldr	r2, [r3, #20]
 8000504:	b162      	cbz	r2, 8000520 <i2s_lld_start_exchange.constprop.0+0x50>
    dmaStreamSetMode(i2sp->dmatx, i2sp->txdmamode);
 8000506:	6812      	ldr	r2, [r2, #0]
 8000508:	69dd      	ldr	r5, [r3, #28]
    dmaStreamSetPeripheral(i2sp->dmatx, &i2sp->spi->DR);
    dmaStreamSetMemory0(i2sp->dmatx, i2sp->config->tx_buffer);
 800050a:	6803      	ldr	r3, [r0, #0]
    dmaStreamSetMode(i2sp->dmatx, i2sp->txdmamode);
 800050c:	6015      	str	r5, [r2, #0]
    dmaStreamSetPeripheral(i2sp->dmatx, &i2sp->spi->DR);
 800050e:	f101 000c 	add.w	r0, r1, #12
 8000512:	6090      	str	r0, [r2, #8]
    dmaStreamSetMemory0(i2sp->dmatx, i2sp->config->tx_buffer);
 8000514:	60d3      	str	r3, [r2, #12]
    dmaStreamSetTransactionSize(i2sp->dmatx, size);
 8000516:	6054      	str	r4, [r2, #4]
    dmaStreamEnable(i2sp->dmatx);
 8000518:	6813      	ldr	r3, [r2, #0]
 800051a:	f043 0301 	orr.w	r3, r3, #1
 800051e:	6013      	str	r3, [r2, #0]
  }

  /* Starting transfer.*/
  i2sp->spi->I2SCFGR |= SPI_I2SCFGR_I2SE;
 8000520:	69cb      	ldr	r3, [r1, #28]
 8000522:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
}
 8000526:	bc70      	pop	{r4, r5, r6}
  i2sp->spi->I2SCFGR |= SPI_I2SCFGR_I2SE;
 8000528:	61cb      	str	r3, [r1, #28]
}
 800052a:	4770      	bx	lr
 800052c:	20000c00 	.word	0x20000c00

08000530 <_pal_lld_setgroupmode.constprop.0>:
 * @param[in] mask      the group mask
 * @param[in] mode      the mode
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
 8000530:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
                           ioportmask_t mask,
                           iomode_t mode) {

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 8000534:	2503      	movs	r5, #3
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
 8000536:	46ab      	mov	fp, r5
  uint32_t bit     = 0;
 8000538:	2200      	movs	r2, #0
  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 800053a:	2602      	movs	r6, #2
      altrmask = altr << ((bit & 7) * 4);
 800053c:	f04f 0a05 	mov.w	sl, #5
      m4 = 15 << ((bit & 7) * 4);
 8000540:	f04f 090f 	mov.w	r9, #15
 8000544:	e010      	b.n	8000568 <_pal_lld_setgroupmode.constprop.0+0x38>
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8000546:	6a04      	ldr	r4, [r0, #32]
 8000548:	ea24 0303 	bic.w	r3, r4, r3
 800054c:	ea43 030c 	orr.w	r3, r3, ip
 8000550:	6203      	str	r3, [r0, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
        port->MODER   = (port->MODER & ~m2) | moder;
 8000552:	6803      	ldr	r3, [r0, #0]
 8000554:	ea0e 0e03 	and.w	lr, lr, r3
 8000558:	ea4e 0306 	orr.w	r3, lr, r6
 800055c:	6003      	str	r3, [r0, #0]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
      }
    }
    mask >>= 1;
    if (!mask)
 800055e:	0849      	lsrs	r1, r1, #1
 8000560:	d02c      	beq.n	80005bc <_pal_lld_setgroupmode.constprop.0+0x8c>
      return;
    otyper <<= 1;
    ospeedr <<= 2;
 8000562:	00ad      	lsls	r5, r5, #2
    pupdr <<= 2;
    moder <<= 2;
 8000564:	00b6      	lsls	r6, r6, #2
    bit++;
 8000566:	3201      	adds	r2, #1
      m1 = 1 << bit;
 8000568:	2301      	movs	r3, #1
      m2 = 3 << (bit * 2);
 800056a:	fa02 f403 	lsl.w	r4, r2, r3
      m1 = 1 << bit;
 800056e:	fa03 f702 	lsl.w	r7, r3, r2
      altrmask = altr << ((bit & 7) * 4);
 8000572:	f002 0307 	and.w	r3, r2, #7
 8000576:	009b      	lsls	r3, r3, #2
      m2 = 3 << (bit * 2);
 8000578:	fa0b f404 	lsl.w	r4, fp, r4
    if ((mask & 1) != 0) {
 800057c:	f011 0f01 	tst.w	r1, #1
      altrmask = altr << ((bit & 7) * 4);
 8000580:	fa0a fc03 	lsl.w	ip, sl, r3
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8000584:	ea6f 0e04 	mvn.w	lr, r4
      m4 = 15 << ((bit & 7) * 4);
 8000588:	fa09 f303 	lsl.w	r3, r9, r3
    if ((mask & 1) != 0) {
 800058c:	d0e7      	beq.n	800055e <_pal_lld_setgroupmode.constprop.0+0x2e>
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 800058e:	f8d0 8004 	ldr.w	r8, [r0, #4]
 8000592:	ea28 0707 	bic.w	r7, r8, r7
 8000596:	6047      	str	r7, [r0, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8000598:	6887      	ldr	r7, [r0, #8]
 800059a:	ea27 0704 	bic.w	r7, r7, r4
 800059e:	432f      	orrs	r7, r5
 80005a0:	6087      	str	r7, [r0, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 80005a2:	68c7      	ldr	r7, [r0, #12]
        if (bit < 8)
 80005a4:	2a07      	cmp	r2, #7
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 80005a6:	ea27 0404 	bic.w	r4, r7, r4
 80005aa:	60c4      	str	r4, [r0, #12]
        if (bit < 8)
 80005ac:	d9cb      	bls.n	8000546 <_pal_lld_setgroupmode.constprop.0+0x16>
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 80005ae:	6a44      	ldr	r4, [r0, #36]	; 0x24
 80005b0:	ea24 0303 	bic.w	r3, r4, r3
 80005b4:	ea43 030c 	orr.w	r3, r3, ip
 80005b8:	6243      	str	r3, [r0, #36]	; 0x24
 80005ba:	e7ca      	b.n	8000552 <_pal_lld_setgroupmode.constprop.0+0x22>
  }
}
 80005bc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080005c0 <chCoreAllocFromTop>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocFromTop(size_t size, unsigned align, size_t offset) {
 80005c0:	b430      	push	{r4, r5}
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80005c2:	2320      	movs	r3, #32
 80005c4:	f383 8811 	msr	BASEPRI, r3
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 80005c8:	4c0b      	ldr	r4, [pc, #44]	; (80005f8 <chCoreAllocFromTop+0x38>)
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 80005ca:	e9d4 3500 	ldrd	r3, r5, [r4]
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 80005ce:	4249      	negs	r1, r1
 80005d0:	1a28      	subs	r0, r5, r0
 80005d2:	4008      	ands	r0, r1
  prev = p - offset;
 80005d4:	1a82      	subs	r2, r0, r2
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 80005d6:	429a      	cmp	r2, r3
 80005d8:	d307      	bcc.n	80005ea <chCoreAllocFromTop+0x2a>
 80005da:	4295      	cmp	r5, r2
 80005dc:	d305      	bcc.n	80005ea <chCoreAllocFromTop+0x2a>
  ch_memcore.topmem = prev;
 80005de:	6062      	str	r2, [r4, #4]
 80005e0:	2300      	movs	r3, #0
 80005e2:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocFromTopI(size, align, offset);
  chSysUnlock();

  return p;
}
 80005e6:	bc30      	pop	{r4, r5}
 80005e8:	4770      	bx	lr
    return NULL;
 80005ea:	2000      	movs	r0, #0
 80005ec:	2300      	movs	r3, #0
 80005ee:	f383 8811 	msr	BASEPRI, r3
}
 80005f2:	bc30      	pop	{r4, r5}
 80005f4:	4770      	bx	lr
 80005f6:	bf00      	nop
 80005f8:	20000f38 	.word	0x20000f38
 80005fc:	00000000 	.word	0x00000000

08000600 <notify1>:

#if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {

  (void)qp;
  USART1->CR1 |= USART_CR1_TXEIE | USART_CR1_TCIE;
 8000600:	4a02      	ldr	r2, [pc, #8]	; (800060c <notify1+0xc>)
 8000602:	68d3      	ldr	r3, [r2, #12]
 8000604:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8000608:	60d3      	str	r3, [r2, #12]
}
 800060a:	4770      	bx	lr
 800060c:	40011000 	.word	0x40011000

08000610 <notify2>:

#if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)
static void notify2(io_queue_t *qp) {

  (void)qp;
  USART2->CR1 |= USART_CR1_TXEIE | USART_CR1_TCIE;
 8000610:	4a02      	ldr	r2, [pc, #8]	; (800061c <notify2+0xc>)
 8000612:	68d3      	ldr	r3, [r2, #12]
 8000614:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8000618:	60d3      	str	r3, [r2, #12]
}
 800061a:	4770      	bx	lr
 800061c:	40004400 	.word	0x40004400

08000620 <_port_irq_epilogue>:
 8000620:	2320      	movs	r3, #32
 8000622:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8000626:	4b10      	ldr	r3, [pc, #64]	; (8000668 <_port_irq_epilogue+0x48>)
 8000628:	685b      	ldr	r3, [r3, #4]
 800062a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 800062e:	d102      	bne.n	8000636 <_port_irq_epilogue+0x16>
 8000630:	f383 8811 	msr	BASEPRI, r3
    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
}
 8000634:	4770      	bx	lr
  /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
  return __builtin_arm_get_fpscr();
#else
  uint32_t result;

  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 8000636:	eef1 3a10 	vmrs	r3, fpscr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 800063a:	f3ef 8309 	mrs	r3, PSP
    s_psp -= sizeof (struct port_extctx);
 800063e:	3b68      	subs	r3, #104	; 0x68
    ectxp->xpsr = 0x01000000U;
 8000640:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
    ectxp->fpscr = FPU->FPDSCR;
 8000644:	4a09      	ldr	r2, [pc, #36]	; (800066c <_port_irq_epilogue+0x4c>)
    ectxp->xpsr = 0x01000000U;
 8000646:	61d9      	str	r1, [r3, #28]
    ectxp->fpscr = FPU->FPDSCR;
 8000648:	68d2      	ldr	r2, [r2, #12]
 800064a:	661a      	str	r2, [r3, #96]	; 0x60
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 800064c:	f383 8809 	msr	PSP, r3
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8000650:	4a07      	ldr	r2, [pc, #28]	; (8000670 <_port_irq_epilogue+0x50>)
 8000652:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->prio;
 8000654:	6992      	ldr	r2, [r2, #24]
    if (chSchIsPreemptionRequired()) {
 8000656:	6889      	ldr	r1, [r1, #8]
 8000658:	6892      	ldr	r2, [r2, #8]
 800065a:	4291      	cmp	r1, r2
      ectxp->pc = (uint32_t)_port_switch_from_isr;
 800065c:	bf8c      	ite	hi
 800065e:	4a05      	ldrhi	r2, [pc, #20]	; (8000674 <_port_irq_epilogue+0x54>)
      ectxp->pc = (uint32_t)_port_exit_from_isr;
 8000660:	4a05      	ldrls	r2, [pc, #20]	; (8000678 <_port_irq_epilogue+0x58>)
 8000662:	619a      	str	r2, [r3, #24]
 8000664:	4770      	bx	lr
 8000666:	bf00      	nop
 8000668:	e000ed00 	.word	0xe000ed00
 800066c:	e000ef30 	.word	0xe000ef30
 8000670:	20000d18 	.word	0x20000d18
 8000674:	08000333 	.word	0x08000333
 8000678:	08000336 	.word	0x08000336
 800067c:	00000000 	.word	0x00000000

08000680 <chCoreAllocAlignedI>:
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 8000680:	4a09      	ldr	r2, [pc, #36]	; (80006a8 <chCoreAllocAlignedI+0x28>)
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
 8000682:	b410      	push	{r4}
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 8000684:	e9d2 3400 	ldrd	r3, r4, [r2]
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 8000688:	4249      	negs	r1, r1
 800068a:	1a20      	subs	r0, r4, r0
 800068c:	4008      	ands	r0, r1
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 800068e:	4298      	cmp	r0, r3
 8000690:	d305      	bcc.n	800069e <chCoreAllocAlignedI+0x1e>
 8000692:	4284      	cmp	r4, r0
 8000694:	d303      	bcc.n	800069e <chCoreAllocAlignedI+0x1e>

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
}
 8000696:	f85d 4b04 	ldr.w	r4, [sp], #4
  ch_memcore.topmem = prev;
 800069a:	6050      	str	r0, [r2, #4]
 800069c:	4770      	bx	lr
    return NULL;
 800069e:	2000      	movs	r0, #0
 80006a0:	f85d 4b04 	ldr.w	r4, [sp], #4
 80006a4:	4770      	bx	lr
 80006a6:	bf00      	nop
 80006a8:	20000f38 	.word	0x20000f38
 80006ac:	00000000 	.word	0x00000000

080006b0 <chTMStopMeasurementX>:
 *
 * @return              The realtime counter value.
 */
__STATIC_FORCEINLINE rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 80006b0:	4a0e      	ldr	r2, [pc, #56]	; (80006ec <chTMStopMeasurementX+0x3c>)
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 80006b2:	4b0f      	ldr	r3, [pc, #60]	; (80006f0 <chTMStopMeasurementX+0x40>)
 80006b4:	6852      	ldr	r2, [r2, #4]
 80006b6:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  tmp->last = (now - tmp->last) - offset;
 80006b8:	6881      	ldr	r1, [r0, #8]
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 80006ba:	b430      	push	{r4, r5}
  tmp->last = (now - tmp->last) - offset;
 80006bc:	1ad3      	subs	r3, r2, r3
  tmp->cumulative += (rttime_t)tmp->last;
 80006be:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
  tmp->n++;
 80006c2:	68c2      	ldr	r2, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
 80006c4:	1a5b      	subs	r3, r3, r1
  tmp->n++;
 80006c6:	3201      	adds	r2, #1
  if (tmp->last > tmp->worst) {
 80006c8:	6841      	ldr	r1, [r0, #4]
  tmp->n++;
 80006ca:	60c2      	str	r2, [r0, #12]
  tmp->cumulative += (rttime_t)tmp->last;
 80006cc:	18e4      	adds	r4, r4, r3
  if (tmp->last < tmp->best) {
 80006ce:	6802      	ldr	r2, [r0, #0]
  tmp->last = (now - tmp->last) - offset;
 80006d0:	6083      	str	r3, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 80006d2:	f145 0500 	adc.w	r5, r5, #0
  if (tmp->last > tmp->worst) {
 80006d6:	428b      	cmp	r3, r1
    tmp->worst = tmp->last;
 80006d8:	bf88      	it	hi
 80006da:	6043      	strhi	r3, [r0, #4]
  if (tmp->last < tmp->best) {
 80006dc:	4293      	cmp	r3, r2
  tmp->cumulative += (rttime_t)tmp->last;
 80006de:	e9c0 4504 	strd	r4, r5, [r0, #16]
    tmp->best = tmp->last;
 80006e2:	bf38      	it	cc
 80006e4:	6003      	strcc	r3, [r0, #0]
}
 80006e6:	bc30      	pop	{r4, r5}
 80006e8:	4770      	bx	lr
 80006ea:	bf00      	nop
 80006ec:	e0001000 	.word	0xe0001000
 80006f0:	20000d18 	.word	0x20000d18
	...

08000700 <chTMStartMeasurementX>:
 8000700:	4b01      	ldr	r3, [pc, #4]	; (8000708 <chTMStartMeasurementX+0x8>)
 8000702:	685b      	ldr	r3, [r3, #4]
  tmp->last = chSysGetRealtimeCounterX();
 8000704:	6083      	str	r3, [r0, #8]
}
 8000706:	4770      	bx	lr
 8000708:	e0001000 	.word	0xe0001000
 800070c:	00000000 	.word	0x00000000

08000710 <wakeup>:
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000710:	2320      	movs	r3, #32
 8000712:	f383 8811 	msr	BASEPRI, r3
  switch (tp->state) {
 8000716:	f890 3020 	ldrb.w	r3, [r0, #32]
 800071a:	2b07      	cmp	r3, #7
 800071c:	d80d      	bhi.n	800073a <wakeup+0x2a>
 800071e:	e8df f003 	tbb	[pc, r3]
 8000722:	0c28      	.short	0x0c28
 8000724:	0408240c 	.word	0x0408240c
 8000728:	080c      	.short	0x080c
    chSemFastSignalI(tp->u.wtsemp);
 800072a:	6a42      	ldr	r2, [r0, #36]	; 0x24
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
 800072c:	6893      	ldr	r3, [r2, #8]
 800072e:	3301      	adds	r3, #1
 8000730:	6093      	str	r3, [r2, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8000732:	e9d0 3200 	ldrd	r3, r2, [r0]
 8000736:	6013      	str	r3, [r2, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8000738:	605a      	str	r2, [r3, #4]
static void wakeup(void *p) {
 800073a:	b410      	push	{r4}
  tp->state = CH_STATE_READY;
 800073c:	2200      	movs	r2, #0
  tp->u.rdymsg = MSG_TIMEOUT;
 800073e:	f04f 34ff 	mov.w	r4, #4294967295
  } while (cp->prio >= tp->prio);
 8000742:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.queue;
 8000744:	4b0d      	ldr	r3, [pc, #52]	; (800077c <wakeup+0x6c>)
  tp->u.rdymsg = MSG_TIMEOUT;
 8000746:	6244      	str	r4, [r0, #36]	; 0x24
  tp->state = CH_STATE_READY;
 8000748:	f880 2020 	strb.w	r2, [r0, #32]
    cp = cp->queue.next;
 800074c:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 800074e:	689a      	ldr	r2, [r3, #8]
 8000750:	428a      	cmp	r2, r1
 8000752:	d2fb      	bcs.n	800074c <wakeup+0x3c>
  tp->queue.prev             = cp->queue.prev;
 8000754:	685a      	ldr	r2, [r3, #4]
 8000756:	2100      	movs	r1, #0
 8000758:	e9c0 3200 	strd	r3, r2, [r0]
  tp->queue.prev->queue.next = tp;
 800075c:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 800075e:	6058      	str	r0, [r3, #4]
 8000760:	f381 8811 	msr	BASEPRI, r1
}
 8000764:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000768:	4770      	bx	lr
    *tp->u.wttrp = NULL;
 800076a:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800076c:	2200      	movs	r2, #0
 800076e:	601a      	str	r2, [r3, #0]
    break;
 8000770:	e7e3      	b.n	800073a <wakeup+0x2a>
 8000772:	2300      	movs	r3, #0
 8000774:	f383 8811 	msr	BASEPRI, r3
 8000778:	4770      	bx	lr
 800077a:	bf00      	nop
 800077c:	20000d18 	.word	0x20000d18

08000780 <chSchReadyI>:
  tp->state = CH_STATE_READY;
 8000780:	2200      	movs	r2, #0
  } while (cp->prio >= tp->prio);
 8000782:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.queue;
 8000784:	4b06      	ldr	r3, [pc, #24]	; (80007a0 <chSchReadyI+0x20>)
  tp->state = CH_STATE_READY;
 8000786:	f880 2020 	strb.w	r2, [r0, #32]
    cp = cp->queue.next;
 800078a:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 800078c:	689a      	ldr	r2, [r3, #8]
 800078e:	428a      	cmp	r2, r1
 8000790:	d2fb      	bcs.n	800078a <chSchReadyI+0xa>
  tp->queue.prev             = cp->queue.prev;
 8000792:	685a      	ldr	r2, [r3, #4]
 8000794:	e9c0 3200 	strd	r3, r2, [r0]
  tp->queue.prev->queue.next = tp;
 8000798:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 800079a:	6058      	str	r0, [r3, #4]
}
 800079c:	4770      	bx	lr
 800079e:	bf00      	nop
 80007a0:	20000d18 	.word	0x20000d18
	...

080007b0 <mp45dt02Cb>:
    }
}

/* (*i2scallback_t) */
static void mp45dt02Cb(I2SDriver *i2sp, size_t offset, size_t number)
{
 80007b0:	b510      	push	{r4, lr}
    (void)i2sp;

    chTMStartMeasurementX(&debugTimings.callback);
 80007b2:	4810      	ldr	r0, [pc, #64]	; (80007f4 <mp45dt02Cb+0x44>)
 80007b4:	f7ff ffa4 	bl	8000700 <chTMStartMeasurementX>
 80007b8:	2320      	movs	r3, #32
 80007ba:	f383 8811 	msr	BASEPRI, r3
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (++sp->cnt <= (cnt_t)0) {
 80007be:	4c0e      	ldr	r4, [pc, #56]	; (80007f8 <mp45dt02Cb+0x48>)

    chSysLockFromISR();
    mp45dt02I2sData.offset = offset;
 80007c0:	480e      	ldr	r0, [pc, #56]	; (80007fc <mp45dt02Cb+0x4c>)
 80007c2:	68a3      	ldr	r3, [r4, #8]
 80007c4:	6001      	str	r1, [r0, #0]
 80007c6:	3301      	adds	r3, #1
 80007c8:	2b00      	cmp	r3, #0
    mp45dt02I2sData.number = number;
 80007ca:	6042      	str	r2, [r0, #4]
 80007cc:	60a3      	str	r3, [r4, #8]
 80007ce:	dd07      	ble.n	80007e0 <mp45dt02Cb+0x30>
 80007d0:	2300      	movs	r3, #0
 80007d2:	f383 8811 	msr	BASEPRI, r3
    chSemSignalI(&mp45dt02ProcessingSem);
    chSysUnlockFromISR();

    chTMStopMeasurementX(&debugTimings.callback);
 80007d6:	4807      	ldr	r0, [pc, #28]	; (80007f4 <mp45dt02Cb+0x44>)
}
 80007d8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    chTMStopMeasurementX(&debugTimings.callback);
 80007dc:	f7ff bf68 	b.w	80006b0 <chTMStopMeasurementX>
  thread_t *tp = tqp->next;
 80007e0:	6820      	ldr	r0, [r4, #0]
  tqp->next             = tp->queue.next;
 80007e2:	6803      	ldr	r3, [r0, #0]
 80007e4:	6023      	str	r3, [r4, #0]
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->queue);
    tp->u.rdymsg = MSG_OK;
 80007e6:	2200      	movs	r2, #0
  tqp->next->queue.prev = (thread_t *)tqp;
 80007e8:	605c      	str	r4, [r3, #4]
 80007ea:	6242      	str	r2, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
 80007ec:	f7ff ffc8 	bl	8000780 <chSchReadyI>
 80007f0:	e7ee      	b.n	80007d0 <mp45dt02Cb+0x20>
 80007f2:	bf00      	nop
 80007f4:	20002380 	.word	0x20002380
 80007f8:	20003588 	.word	0x20003588
 80007fc:	2000347c 	.word	0x2000347c

08000800 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8000800:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
 8000802:	6804      	ldr	r4, [r0, #0]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8000804:	42a0      	cmp	r0, r4
 8000806:	d021      	beq.n	800084c <chEvtBroadcastFlagsI+0x4c>
 8000808:	4607      	mov	r7, r0
 800080a:	460d      	mov	r5, r1
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
 800080c:	2600      	movs	r6, #0
 800080e:	e004      	b.n	800081a <chEvtBroadcastFlagsI+0x1a>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8000810:	2a0b      	cmp	r2, #11
 8000812:	d01c      	beq.n	800084e <chEvtBroadcastFlagsI+0x4e>
    elp = elp->next;
 8000814:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
 8000816:	42a7      	cmp	r7, r4
 8000818:	d018      	beq.n	800084c <chEvtBroadcastFlagsI+0x4c>
    elp->flags |= flags;
 800081a:	68e3      	ldr	r3, [r4, #12]
 800081c:	432b      	orrs	r3, r5
 800081e:	60e3      	str	r3, [r4, #12]
    if ((flags == (eventflags_t)0) ||
 8000820:	b115      	cbz	r5, 8000828 <chEvtBroadcastFlagsI+0x28>
        ((flags & elp->wflags) != (eventflags_t)0)) {
 8000822:	6923      	ldr	r3, [r4, #16]
    if ((flags == (eventflags_t)0) ||
 8000824:	421d      	tst	r5, r3
 8000826:	d0f5      	beq.n	8000814 <chEvtBroadcastFlagsI+0x14>
  tp->epending |= events;
 8000828:	e9d4 0301 	ldrd	r0, r3, [r4, #4]
 800082c:	6b41      	ldr	r1, [r0, #52]	; 0x34
  if (((tp->state == CH_STATE_WTOREVT) &&
 800082e:	f890 2020 	ldrb.w	r2, [r0, #32]
  tp->epending |= events;
 8000832:	430b      	orrs	r3, r1
  if (((tp->state == CH_STATE_WTOREVT) &&
 8000834:	2a0a      	cmp	r2, #10
  tp->epending |= events;
 8000836:	6343      	str	r3, [r0, #52]	; 0x34
  if (((tp->state == CH_STATE_WTOREVT) &&
 8000838:	d1ea      	bne.n	8000810 <chEvtBroadcastFlagsI+0x10>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 800083a:	6a42      	ldr	r2, [r0, #36]	; 0x24
  if (((tp->state == CH_STATE_WTOREVT) &&
 800083c:	4213      	tst	r3, r2
 800083e:	d0e9      	beq.n	8000814 <chEvtBroadcastFlagsI+0x14>
    tp->u.rdymsg = MSG_OK;
 8000840:	6246      	str	r6, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
 8000842:	f7ff ff9d 	bl	8000780 <chSchReadyI>
    elp = elp->next;
 8000846:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
 8000848:	42a7      	cmp	r7, r4
 800084a:	d1e6      	bne.n	800081a <chEvtBroadcastFlagsI+0x1a>
}
 800084c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 800084e:	6a42      	ldr	r2, [r0, #36]	; 0x24
      ((tp->state == CH_STATE_WTANDEVT) &&
 8000850:	ea32 0303 	bics.w	r3, r2, r3
 8000854:	d1de      	bne.n	8000814 <chEvtBroadcastFlagsI+0x14>
 8000856:	e7f3      	b.n	8000840 <chEvtBroadcastFlagsI+0x40>
	...

08000860 <_idle_thread>:
}
 8000860:	e7fe      	b.n	8000860 <_idle_thread>
 8000862:	bf00      	nop
	...

08000870 <serve_interrupt>:
static void serve_interrupt(SerialDriver *sdp) {
 8000870:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  USART_TypeDef *u = sdp->usart;
 8000874:	6f46      	ldr	r6, [r0, #116]	; 0x74
  uint16_t cr1 = u->CR1;
 8000876:	f8d6 900c 	ldr.w	r9, [r6, #12]
  uint16_t sr = u->SR;
 800087a:	6833      	ldr	r3, [r6, #0]
  if (sr & USART_SR_LBD) {
 800087c:	05da      	lsls	r2, r3, #23
static void serve_interrupt(SerialDriver *sdp) {
 800087e:	4604      	mov	r4, r0
  uint16_t sr = u->SR;
 8000880:	b29d      	uxth	r5, r3
  if (sr & USART_SR_LBD) {
 8000882:	f100 8081 	bmi.w	8000988 <serve_interrupt+0x118>
 8000886:	2320      	movs	r3, #32
 8000888:	f383 8811 	msr	BASEPRI, r3
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 800088c:	f015 0f2f 	tst.w	r5, #47	; 0x2f
 8000890:	d050      	beq.n	8000934 <serve_interrupt+0xc4>
  chnAddFlagsI(sdp, sts);
 8000892:	1d27      	adds	r7, r4, #4
  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
 8000894:	f104 080c 	add.w	r8, r4, #12

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 8000898:	f04f 0a00 	mov.w	sl, #0
 800089c:	e008      	b.n	80008b0 <serve_interrupt+0x40>
    if (sr & USART_SR_RXNE)
 800089e:	06a8      	lsls	r0, r5, #26
    b = (uint8_t)u->DR & sdp->rxmask;
 80008a0:	f8d6 b004 	ldr.w	fp, [r6, #4]
    if (sr & USART_SR_RXNE)
 80008a4:	d41e      	bmi.n	80008e4 <serve_interrupt+0x74>
    sr = u->SR;
 80008a6:	6833      	ldr	r3, [r6, #0]
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 80008a8:	f013 0f2f 	tst.w	r3, #47	; 0x2f
    sr = u->SR;
 80008ac:	b29d      	uxth	r5, r3
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 80008ae:	d041      	beq.n	8000934 <serve_interrupt+0xc4>
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 80008b0:	072b      	lsls	r3, r5, #28
 80008b2:	d0f4      	beq.n	800089e <serve_interrupt+0x2e>
    sts |= SD_OVERRUN_ERROR;
 80008b4:	f015 0f08 	tst.w	r5, #8
 80008b8:	bf0c      	ite	eq
 80008ba:	2100      	moveq	r1, #0
 80008bc:	2180      	movne	r1, #128	; 0x80
  if (sr & USART_SR_PE)
 80008be:	07e8      	lsls	r0, r5, #31
    sts |= SD_PARITY_ERROR;
 80008c0:	bf48      	it	mi
 80008c2:	f041 0120 	orrmi.w	r1, r1, #32
  if (sr & USART_SR_FE)
 80008c6:	07aa      	lsls	r2, r5, #30
    sts |= SD_FRAMING_ERROR;
 80008c8:	bf48      	it	mi
 80008ca:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40
  if (sr & USART_SR_NE)
 80008ce:	076b      	lsls	r3, r5, #29
    sts |= SD_NOISE_ERROR;
 80008d0:	bf48      	it	mi
 80008d2:	f441 7180 	orrmi.w	r1, r1, #256	; 0x100
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 80008d6:	4638      	mov	r0, r7
 80008d8:	f7ff ff92 	bl	8000800 <chEvtBroadcastFlagsI>
    if (sr & USART_SR_RXNE)
 80008dc:	06a8      	lsls	r0, r5, #26
    b = (uint8_t)u->DR & sdp->rxmask;
 80008de:	f8d6 b004 	ldr.w	fp, [r6, #4]
    if (sr & USART_SR_RXNE)
 80008e2:	d5e0      	bpl.n	80008a6 <serve_interrupt+0x36>
  if (iqIsEmptyI(&sdp->iqueue))
 80008e4:	6963      	ldr	r3, [r4, #20]
    b = (uint8_t)u->DR & sdp->rxmask;
 80008e6:	f894 5078 	ldrb.w	r5, [r4, #120]	; 0x78
 80008ea:	2b00      	cmp	r3, #0
 80008ec:	d03b      	beq.n	8000966 <serve_interrupt+0xf6>
  if (!iqIsFullI(iqp)) {
 80008ee:	e9d4 3208 	ldrd	r3, r2, [r4, #32]
 80008f2:	4293      	cmp	r3, r2
 80008f4:	d03f      	beq.n	8000976 <serve_interrupt+0x106>
    iqp->q_counter++;
 80008f6:	6962      	ldr	r2, [r4, #20]
    *iqp->q_wrptr++ = b;
 80008f8:	1c59      	adds	r1, r3, #1
    iqp->q_counter++;
 80008fa:	3201      	adds	r2, #1
 80008fc:	ea05 0b0b 	and.w	fp, r5, fp
 8000900:	6162      	str	r2, [r4, #20]
    *iqp->q_wrptr++ = b;
 8000902:	6221      	str	r1, [r4, #32]
 8000904:	f883 b000 	strb.w	fp, [r3]
    if (iqp->q_wrptr >= iqp->q_top) {
 8000908:	e9d4 3207 	ldrd	r3, r2, [r4, #28]
 800090c:	429a      	cmp	r2, r3
 800090e:	d301      	bcc.n	8000914 <serve_interrupt+0xa4>
      iqp->q_wrptr = iqp->q_buffer;
 8000910:	69a3      	ldr	r3, [r4, #24]
 8000912:	6223      	str	r3, [r4, #32]
  return (bool)(tqp->next != (const thread_t *)tqp);
 8000914:	68e0      	ldr	r0, [r4, #12]
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
 8000916:	4580      	cmp	r8, r0
 8000918:	d0c5      	beq.n	80008a6 <serve_interrupt+0x36>
  tqp->next             = tp->queue.next;
 800091a:	6803      	ldr	r3, [r0, #0]
 800091c:	60e3      	str	r3, [r4, #12]
  tqp->next->queue.prev = (thread_t *)tqp;
 800091e:	f8c3 8004 	str.w	r8, [r3, #4]
 8000922:	f8c0 a024 	str.w	sl, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 8000926:	f7ff ff2b 	bl	8000780 <chSchReadyI>
    sr = u->SR;
 800092a:	6833      	ldr	r3, [r6, #0]
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 800092c:	f013 0f2f 	tst.w	r3, #47	; 0x2f
    sr = u->SR;
 8000930:	b29d      	uxth	r5, r3
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8000932:	d1bd      	bne.n	80008b0 <serve_interrupt+0x40>
 8000934:	2300      	movs	r3, #0
 8000936:	f383 8811 	msr	BASEPRI, r3
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 800093a:	f019 0f80 	tst.w	r9, #128	; 0x80
 800093e:	d001      	beq.n	8000944 <serve_interrupt+0xd4>
 8000940:	062a      	lsls	r2, r5, #24
 8000942:	d430      	bmi.n	80009a6 <serve_interrupt+0x136>
  if ((cr1 & USART_CR1_TCIE) && (sr & USART_SR_TC)) {
 8000944:	f019 0f40 	tst.w	r9, #64	; 0x40
 8000948:	d00b      	beq.n	8000962 <serve_interrupt+0xf2>
 800094a:	066b      	lsls	r3, r5, #25
 800094c:	d509      	bpl.n	8000962 <serve_interrupt+0xf2>
 800094e:	2320      	movs	r3, #32
 8000950:	f383 8811 	msr	BASEPRI, r3
    if (oqIsEmptyI(&sdp->oqueue)) {
 8000954:	e9d4 2311 	ldrd	r2, r3, [r4, #68]	; 0x44
 8000958:	429a      	cmp	r2, r3
 800095a:	d049      	beq.n	80009f0 <serve_interrupt+0x180>
 800095c:	2300      	movs	r3, #0
 800095e:	f383 8811 	msr	BASEPRI, r3
}
 8000962:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000966:	2104      	movs	r1, #4
 8000968:	4638      	mov	r0, r7
 800096a:	f7ff ff49 	bl	8000800 <chEvtBroadcastFlagsI>
  if (!iqIsFullI(iqp)) {
 800096e:	e9d4 3208 	ldrd	r3, r2, [r4, #32]
 8000972:	4293      	cmp	r3, r2
 8000974:	d1bf      	bne.n	80008f6 <serve_interrupt+0x86>
 8000976:	6962      	ldr	r2, [r4, #20]
 8000978:	2a00      	cmp	r2, #0
 800097a:	d0bc      	beq.n	80008f6 <serve_interrupt+0x86>
 800097c:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8000980:	4638      	mov	r0, r7
 8000982:	f7ff ff3d 	bl	8000800 <chEvtBroadcastFlagsI>
 8000986:	e78e      	b.n	80008a6 <serve_interrupt+0x36>
 8000988:	2320      	movs	r3, #32
 800098a:	f383 8811 	msr	BASEPRI, r3
 800098e:	f44f 7100 	mov.w	r1, #512	; 0x200
 8000992:	3004      	adds	r0, #4
 8000994:	f7ff ff34 	bl	8000800 <chEvtBroadcastFlagsI>
    u->SR = ~USART_SR_LBD;
 8000998:	f46f 7380 	mvn.w	r3, #256	; 0x100
 800099c:	6033      	str	r3, [r6, #0]
 800099e:	2300      	movs	r3, #0
 80009a0:	f383 8811 	msr	BASEPRI, r3
 80009a4:	e76f      	b.n	8000886 <serve_interrupt+0x16>
 80009a6:	2320      	movs	r3, #32
 80009a8:	f383 8811 	msr	BASEPRI, r3
msg_t oqGetI(output_queue_t *oqp) {

  osalDbgCheckClassI();

  /* Queue data check.*/
  if (!oqIsEmptyI(oqp)) {
 80009ac:	e9d4 2311 	ldrd	r2, r3, [r4, #68]	; 0x44
 80009b0:	429a      	cmp	r2, r3
    b = oqGetI(&sdp->oqueue);
 80009b2:	f104 0730 	add.w	r7, r4, #48	; 0x30
 80009b6:	d028      	beq.n	8000a0a <serve_interrupt+0x19a>
    uint8_t b;

    oqp->q_counter++;
 80009b8:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    b = *oqp->q_rdptr++;
    if (oqp->q_rdptr >= oqp->q_top) {
 80009ba:	6c21      	ldr	r1, [r4, #64]	; 0x40
    b = *oqp->q_rdptr++;
 80009bc:	1c58      	adds	r0, r3, #1
    oqp->q_counter++;
 80009be:	3201      	adds	r2, #1
 80009c0:	63a2      	str	r2, [r4, #56]	; 0x38
    b = *oqp->q_rdptr++;
 80009c2:	64a0      	str	r0, [r4, #72]	; 0x48
    if (oqp->q_rdptr >= oqp->q_top) {
 80009c4:	4288      	cmp	r0, r1
    b = *oqp->q_rdptr++;
 80009c6:	f893 8000 	ldrb.w	r8, [r3]
    if (oqp->q_rdptr >= oqp->q_top) {
 80009ca:	d301      	bcc.n	80009d0 <serve_interrupt+0x160>
      oqp->q_rdptr = oqp->q_buffer;
 80009cc:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80009ce:	64a3      	str	r3, [r4, #72]	; 0x48
  return (bool)(tqp->next != (const thread_t *)tqp);
 80009d0:	6b20      	ldr	r0, [r4, #48]	; 0x30
 80009d2:	4287      	cmp	r7, r0
 80009d4:	d006      	beq.n	80009e4 <serve_interrupt+0x174>
  tqp->next             = tp->queue.next;
 80009d6:	6803      	ldr	r3, [r0, #0]
 80009d8:	6323      	str	r3, [r4, #48]	; 0x30
  tp->u.rdymsg = msg;
 80009da:	2200      	movs	r2, #0
  tqp->next->queue.prev = (thread_t *)tqp;
 80009dc:	605f      	str	r7, [r3, #4]
 80009de:	6242      	str	r2, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 80009e0:	f7ff fece 	bl	8000780 <chSchReadyI>
      u->DR = b;
 80009e4:	f8c6 8004 	str.w	r8, [r6, #4]
 80009e8:	2300      	movs	r3, #0
 80009ea:	f383 8811 	msr	BASEPRI, r3
 80009ee:	e7a9      	b.n	8000944 <serve_interrupt+0xd4>
    if (oqIsEmptyI(&sdp->oqueue)) {
 80009f0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80009f2:	2b00      	cmp	r3, #0
 80009f4:	d0b2      	beq.n	800095c <serve_interrupt+0xec>
 80009f6:	1d20      	adds	r0, r4, #4
 80009f8:	2110      	movs	r1, #16
 80009fa:	f7ff ff01 	bl	8000800 <chEvtBroadcastFlagsI>
      u->CR1 = cr1 & ~USART_CR1_TCIE;
 80009fe:	f64f 73bf 	movw	r3, #65471	; 0xffbf
 8000a02:	ea09 0303 	and.w	r3, r9, r3
 8000a06:	60f3      	str	r3, [r6, #12]
 8000a08:	e7a8      	b.n	800095c <serve_interrupt+0xec>
  if (!oqIsEmptyI(oqp)) {
 8000a0a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8000a0c:	2a00      	cmp	r2, #0
 8000a0e:	d0d3      	beq.n	80009b8 <serve_interrupt+0x148>
 8000a10:	2108      	movs	r1, #8
 8000a12:	1d20      	adds	r0, r4, #4
 8000a14:	f7ff fef4 	bl	8000800 <chEvtBroadcastFlagsI>
      u->CR1 = cr1 & ~USART_CR1_TXEIE;
 8000a18:	f64f 737f 	movw	r3, #65407	; 0xff7f
 8000a1c:	ea09 0303 	and.w	r3, r9, r3
 8000a20:	60f3      	str	r3, [r6, #12]
 8000a22:	e7e1      	b.n	80009e8 <serve_interrupt+0x178>
	...

08000a30 <i2s_lld_serve_rx_interrupt>:
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8000a30:	f011 0f0c 	tst.w	r1, #12
 8000a34:	d116      	bne.n	8000a64 <i2s_lld_serve_rx_interrupt+0x34>
  if ((flags & STM32_DMA_ISR_TCIF) != 0) {
 8000a36:	068a      	lsls	r2, r1, #26
static void i2s_lld_serve_rx_interrupt(I2SDriver *i2sp, uint32_t flags) {
 8000a38:	b510      	push	{r4, lr}
 8000a3a:	4604      	mov	r4, r0
  if ((flags & STM32_DMA_ISR_TCIF) != 0) {
 8000a3c:	d509      	bpl.n	8000a52 <i2s_lld_serve_rx_interrupt+0x22>
    _i2s_isr_full_code(i2sp);
 8000a3e:	6843      	ldr	r3, [r0, #4]
 8000a40:	68db      	ldr	r3, [r3, #12]
 8000a42:	b12b      	cbz	r3, 8000a50 <i2s_lld_serve_rx_interrupt+0x20>
 8000a44:	2204      	movs	r2, #4
 8000a46:	7002      	strb	r2, [r0, #0]
 8000a48:	4798      	blx	r3
 8000a4a:	7823      	ldrb	r3, [r4, #0]
 8000a4c:	2b04      	cmp	r3, #4
 8000a4e:	d00e      	beq.n	8000a6e <i2s_lld_serve_rx_interrupt+0x3e>
}
 8000a50:	bd10      	pop	{r4, pc}
  else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
 8000a52:	06cb      	lsls	r3, r1, #27
 8000a54:	d5fc      	bpl.n	8000a50 <i2s_lld_serve_rx_interrupt+0x20>
    _i2s_isr_half_code(i2sp);
 8000a56:	6843      	ldr	r3, [r0, #4]
 8000a58:	68db      	ldr	r3, [r3, #12]
 8000a5a:	2b00      	cmp	r3, #0
 8000a5c:	d0f8      	beq.n	8000a50 <i2s_lld_serve_rx_interrupt+0x20>
}
 8000a5e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    _i2s_isr_half_code(i2sp);
 8000a62:	4718      	bx	r3
  __ASM volatile ("cpsid i" : : : "memory");
 8000a64:	b672      	cpsid	i

  /* Logging the event.*/
  _trace_halt(reason);

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8000a66:	4b03      	ldr	r3, [pc, #12]	; (8000a74 <i2s_lld_serve_rx_interrupt+0x44>)
 8000a68:	4a03      	ldr	r2, [pc, #12]	; (8000a78 <i2s_lld_serve_rx_interrupt+0x48>)
 8000a6a:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Halt hook code, usually empty.*/
  CH_CFG_SYSTEM_HALT_HOOK(reason);

  /* Harmless infinite loop.*/
  while (true) {
 8000a6c:	e7fe      	b.n	8000a6c <i2s_lld_serve_rx_interrupt+0x3c>
    _i2s_isr_full_code(i2sp);
 8000a6e:	2303      	movs	r3, #3
 8000a70:	7023      	strb	r3, [r4, #0]
}
 8000a72:	bd10      	pop	{r4, pc}
 8000a74:	20000d18 	.word	0x20000d18
 8000a78:	080024a4 	.word	0x080024a4
 8000a7c:	00000000 	.word	0x00000000

08000a80 <_ctl>:
}
 8000a80:	2000      	movs	r0, #0
 8000a82:	4770      	bx	lr
	...

08000a90 <chSchWakeupS.constprop.0>:
  thread_t *otp = currp;
 8000a90:	4b14      	ldr	r3, [pc, #80]	; (8000ae4 <chSchWakeupS.constprop.0+0x54>)
 8000a92:	6999      	ldr	r1, [r3, #24]
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8000a94:	b430      	push	{r4, r5}
  if (ntp->prio <= otp->prio) {
 8000a96:	688d      	ldr	r5, [r1, #8]
 8000a98:	6884      	ldr	r4, [r0, #8]
  ntp->u.rdymsg = msg;
 8000a9a:	2200      	movs	r2, #0
  if (ntp->prio <= otp->prio) {
 8000a9c:	42ac      	cmp	r4, r5
  ntp->u.rdymsg = msg;
 8000a9e:	6242      	str	r2, [r0, #36]	; 0x24
  if (ntp->prio <= otp->prio) {
 8000aa0:	d80c      	bhi.n	8000abc <chSchWakeupS.constprop.0+0x2c>
  tp->state = CH_STATE_READY;
 8000aa2:	f880 2020 	strb.w	r2, [r0, #32]
    cp = cp->queue.next;
 8000aa6:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8000aa8:	689a      	ldr	r2, [r3, #8]
 8000aaa:	4294      	cmp	r4, r2
 8000aac:	d9fb      	bls.n	8000aa6 <chSchWakeupS.constprop.0+0x16>
  tp->queue.prev             = cp->queue.prev;
 8000aae:	685a      	ldr	r2, [r3, #4]
}
 8000ab0:	bc30      	pop	{r4, r5}
  tp->queue.prev             = cp->queue.prev;
 8000ab2:	e9c0 3200 	strd	r3, r2, [r0]
  tp->queue.prev->queue.next = tp;
 8000ab6:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 8000ab8:	6058      	str	r0, [r3, #4]
}
 8000aba:	4770      	bx	lr
  tp->state = CH_STATE_READY;
 8000abc:	f881 2020 	strb.w	r2, [r1, #32]
  cp = (thread_t *)&ch.rlist.queue;
 8000ac0:	461a      	mov	r2, r3
    cp = cp->queue.next;
 8000ac2:	6812      	ldr	r2, [r2, #0]
  } while (cp->prio > tp->prio);
 8000ac4:	6894      	ldr	r4, [r2, #8]
 8000ac6:	42a5      	cmp	r5, r4
 8000ac8:	d3fb      	bcc.n	8000ac2 <chSchWakeupS.constprop.0+0x32>
  tp->queue.prev             = cp->queue.prev;
 8000aca:	6854      	ldr	r4, [r2, #4]
 8000acc:	604c      	str	r4, [r1, #4]
    ntp->state = CH_STATE_CURRENT;
 8000ace:	2501      	movs	r5, #1
  tp->queue.next             = cp;
 8000ad0:	600a      	str	r2, [r1, #0]
  tp->queue.prev->queue.next = tp;
 8000ad2:	6021      	str	r1, [r4, #0]
  cp->queue.prev             = tp;
 8000ad4:	6051      	str	r1, [r2, #4]
    ntp->state = CH_STATE_CURRENT;
 8000ad6:	f880 5020 	strb.w	r5, [r0, #32]
}
 8000ada:	bc30      	pop	{r4, r5}
    currp = ntp;
 8000adc:	6198      	str	r0, [r3, #24]
    chSysSwitch(ntp, otp);
 8000ade:	f7ff bc13 	b.w	8000308 <_port_switch>
 8000ae2:	bf00      	nop
 8000ae4:	20000d18 	.word	0x20000d18
	...

08000af0 <chThdCreateStatic.constprop.0>:
thread_t *chThdCreateStatic(void *wsp, size_t size,
 8000af0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000af2:	2320      	movs	r3, #32
 8000af4:	f383 8811 	msr	BASEPRI, r3
  tp = (thread_t *)((uint8_t *)wsp + size -
 8000af8:	3948      	subs	r1, #72	; 0x48
 8000afa:	1844      	adds	r4, r0, r1
  REG_INSERT(tp);
 8000afc:	4b15      	ldr	r3, [pc, #84]	; (8000b54 <chThdCreateStatic.constprop.0+0x64>)
 8000afe:	6123      	str	r3, [r4, #16]
 8000b00:	6959      	ldr	r1, [r3, #20]
  tp->wabase = (stkalign_t *)wsp;
 8000b02:	61e0      	str	r0, [r4, #28]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8000b04:	f844 2c24 	str.w	r2, [r4, #-36]
 8000b08:	f1a4 0664 	sub.w	r6, r4, #100	; 0x64
 8000b0c:	4d12      	ldr	r5, [pc, #72]	; (8000b58 <chThdCreateStatic.constprop.0+0x68>)
 8000b0e:	60e6      	str	r6, [r4, #12]
  tp->state     = CH_STATE_WTSTART;
 8000b10:	2002      	movs	r0, #2
  tp->refs      = (trefs_t)1;
 8000b12:	2201      	movs	r2, #1
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8000b14:	f844 5c04 	str.w	r5, [r4, #-4]
  tp->state     = CH_STATE_WTSTART;
 8000b18:	8420      	strh	r0, [r4, #32]
  tp->refs      = (trefs_t)1;
 8000b1a:	f884 2022 	strb.w	r2, [r4, #34]	; 0x22
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8000b1e:	2500      	movs	r5, #0
  queue_init(&tp->msgqueue);
 8000b20:	f104 022c 	add.w	r2, r4, #44	; 0x2c
  tp->prio      = prio;
 8000b24:	2080      	movs	r0, #128	; 0x80
  tp->name      = name;
 8000b26:	4f0d      	ldr	r7, [pc, #52]	; (8000b5c <chThdCreateStatic.constprop.0+0x6c>)
  tp->prio      = prio;
 8000b28:	60a0      	str	r0, [r4, #8]
  list_init(&tp->waiting);
 8000b2a:	f104 0628 	add.w	r6, r4, #40	; 0x28
  REG_INSERT(tp);
 8000b2e:	6161      	str	r1, [r4, #20]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8000b30:	f844 5c20 	str.w	r5, [r4, #-32]
  tp->realprio  = prio;
 8000b34:	63e0      	str	r0, [r4, #60]	; 0x3c
  tp->epending  = (eventmask_t)0;
 8000b36:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
  tp->name      = name;
 8000b3a:	61a7      	str	r7, [r4, #24]
  chSchWakeupS(tp, MSG_OK);
 8000b3c:	4620      	mov	r0, r4
  REG_INSERT(tp);
 8000b3e:	610c      	str	r4, [r1, #16]
  tqp->next = (thread_t *)tqp;
 8000b40:	e9c4 620a 	strd	r6, r2, [r4, #40]	; 0x28
  tqp->prev = (thread_t *)tqp;
 8000b44:	6322      	str	r2, [r4, #48]	; 0x30
 8000b46:	615c      	str	r4, [r3, #20]
  chSchWakeupS(tp, MSG_OK);
 8000b48:	f7ff ffa2 	bl	8000a90 <chSchWakeupS.constprop.0>
 8000b4c:	f385 8811 	msr	BASEPRI, r5
}
 8000b50:	4620      	mov	r0, r4
 8000b52:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000b54:	20000d18 	.word	0x20000d18
 8000b58:	08000321 	.word	0x08000321
 8000b5c:	080024b0 	.word	0x080024b0

08000b60 <chSchGoSleepS>:
  thread_t *otp = currp;
 8000b60:	4b08      	ldr	r3, [pc, #32]	; (8000b84 <chSchGoSleepS+0x24>)
 8000b62:	6999      	ldr	r1, [r3, #24]
  thread_t *tp = tqp->next;
 8000b64:	681a      	ldr	r2, [r3, #0]
void chSchGoSleepS(tstate_t newstate) {
 8000b66:	b410      	push	{r4}
  otp->state = newstate;
 8000b68:	f881 0020 	strb.w	r0, [r1, #32]
  tqp->next             = tp->queue.next;
 8000b6c:	6810      	ldr	r0, [r2, #0]
 8000b6e:	6018      	str	r0, [r3, #0]
  currp->state = CH_STATE_CURRENT;
 8000b70:	2401      	movs	r4, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 8000b72:	6043      	str	r3, [r0, #4]
 8000b74:	f882 4020 	strb.w	r4, [r2, #32]
}
 8000b78:	f85d 4b04 	ldr.w	r4, [sp], #4
  currp = queue_fifo_remove(&ch.rlist.queue);
 8000b7c:	619a      	str	r2, [r3, #24]
  chSysSwitch(currp, otp);
 8000b7e:	4610      	mov	r0, r2
 8000b80:	f7ff bbc2 	b.w	8000308 <_port_switch>
 8000b84:	20000d18 	.word	0x20000d18
	...

08000b90 <chSchGoSleepTimeoutS>:
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 8000b90:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (TIME_INFINITE != timeout) {
 8000b92:	1c4b      	adds	r3, r1, #1
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 8000b94:	b087      	sub	sp, #28
  if (TIME_INFINITE != timeout) {
 8000b96:	d049      	beq.n	8000c2c <chSchGoSleepTimeoutS+0x9c>
    chVTDoSetI(&vt, timeout, wakeup, currp);
 8000b98:	4c3f      	ldr	r4, [pc, #252]	; (8000c98 <chSchGoSleepTimeoutS+0x108>)

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
  vtp->func = vtfunc;
 8000b9a:	4f40      	ldr	r7, [pc, #256]	; (8000c9c <chSchGoSleepTimeoutS+0x10c>)
  vtp->par = par;
 8000b9c:	69a3      	ldr	r3, [r4, #24]
 8000b9e:	9305      	str	r3, [sp, #20]
    if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8000ba0:	4626      	mov	r6, r4
 8000ba2:	2902      	cmp	r1, #2
 8000ba4:	f856 3f1c 	ldr.w	r3, [r6, #28]!
 8000ba8:	4605      	mov	r5, r0
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000baa:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8000bae:	bf38      	it	cc
 8000bb0:	2102      	movcc	r1, #2
 8000bb2:	42b3      	cmp	r3, r6
 8000bb4:	6a42      	ldr	r2, [r0, #36]	; 0x24
  vtp->func = vtfunc;
 8000bb6:	9704      	str	r7, [sp, #16]
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8000bb8:	d05b      	beq.n	8000c72 <chSchGoSleepTimeoutS+0xe2>
    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.next;

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = chTimeDiffX(ch.vtlist.lasttime, now) + delay;
 8000bba:	6aa7      	ldr	r7, [r4, #40]	; 0x28
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 8000bbc:	1bd2      	subs	r2, r2, r7
 8000bbe:	1889      	adds	r1, r1, r2

    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
 8000bc0:	d32e      	bcc.n	8000c20 <chSchGoSleepTimeoutS+0x90>
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 8000bc2:	6898      	ldr	r0, [r3, #8]
      p = p->next;
 8000bc4:	681b      	ldr	r3, [r3, #0]
 8000bc6:	689a      	ldr	r2, [r3, #8]
      delta -= p->delta;
 8000bc8:	1a09      	subs	r1, r1, r0
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
 8000bca:	4291      	cmp	r1, r2
 8000bcc:	d904      	bls.n	8000bd8 <chSchGoSleepTimeoutS+0x48>
    /* Debug assert if the timer is already in the list.*/
    chDbgAssert(p != vtp, "timer already armed");

    delta -= p->delta;
    p = p->next;
 8000bce:	681b      	ldr	r3, [r3, #0]
    delta -= p->delta;
 8000bd0:	1a89      	subs	r1, r1, r2
  while (p->delta < delta) {
 8000bd2:	689a      	ldr	r2, [r3, #8]
 8000bd4:	428a      	cmp	r2, r1
 8000bd6:	d3fa      	bcc.n	8000bce <chSchGoSleepTimeoutS+0x3e>
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
 8000bd8:	685a      	ldr	r2, [r3, #4]
 8000bda:	9202      	str	r2, [sp, #8]
  vtp->prev->next = vtp;
 8000bdc:	af01      	add	r7, sp, #4
  vtp->next = p;
 8000bde:	9301      	str	r3, [sp, #4]
  vtp->prev->next = vtp;
 8000be0:	6017      	str	r7, [r2, #0]
  p->prev = vtp;
 8000be2:	605f      	str	r7, [r3, #4]
  vtp->delta = delta;
 8000be4:	9103      	str	r1, [sp, #12]

  /* Calculate new delta for the following entry.*/
  p->delta -= delta;
 8000be6:	689a      	ldr	r2, [r3, #8]
 8000be8:	1a51      	subs	r1, r2, r1

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/
  ch.vtlist.delta = (sysinterval_t)-1;
 8000bea:	f04f 32ff 	mov.w	r2, #4294967295
  p->delta -= delta;
 8000bee:	6099      	str	r1, [r3, #8]
  ch.vtlist.delta = (sysinterval_t)-1;
 8000bf0:	6262      	str	r2, [r4, #36]	; 0x24
    chSchGoSleepS(newstate);
 8000bf2:	4628      	mov	r0, r5
 8000bf4:	f7ff ffb4 	bl	8000b60 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8000bf8:	9b04      	ldr	r3, [sp, #16]
 8000bfa:	b16b      	cbz	r3, 8000c18 <chSchGoSleepTimeoutS+0x88>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 8000bfc:	69e3      	ldr	r3, [r4, #28]
 8000bfe:	42bb      	cmp	r3, r7
 8000c00:	d01b      	beq.n	8000c3a <chSchGoSleepTimeoutS+0xaa>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 8000c02:	e9dd 3201 	ldrd	r3, r2, [sp, #4]
 8000c06:	6013      	str	r3, [r2, #0]
    vtp->next->prev = vtp->prev;
 8000c08:	9b01      	ldr	r3, [sp, #4]
    vtp->func = NULL;

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8000c0a:	42b3      	cmp	r3, r6
    vtp->next->prev = vtp->prev;
 8000c0c:	605a      	str	r2, [r3, #4]
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8000c0e:	d003      	beq.n	8000c18 <chSchGoSleepTimeoutS+0x88>
      vtp->next->delta += vtp->delta;
 8000c10:	689a      	ldr	r2, [r3, #8]
 8000c12:	9903      	ldr	r1, [sp, #12]
 8000c14:	440a      	add	r2, r1
 8000c16:	609a      	str	r2, [r3, #8]
  return currp->u.rdymsg;
 8000c18:	69a3      	ldr	r3, [r4, #24]
}
 8000c1a:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8000c1c:	b007      	add	sp, #28
 8000c1e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    else if (delta < p->delta) {
 8000c20:	689a      	ldr	r2, [r3, #8]
 8000c22:	4291      	cmp	r1, r2
 8000c24:	d2d1      	bcs.n	8000bca <chSchGoSleepTimeoutS+0x3a>
  return systime + (systime_t)interval;
 8000c26:	440f      	add	r7, r1
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t abstime) {

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8000c28:	6347      	str	r7, [r0, #52]	; 0x34
 8000c2a:	e7ce      	b.n	8000bca <chSchGoSleepTimeoutS+0x3a>
    chSchGoSleepS(newstate);
 8000c2c:	4c1a      	ldr	r4, [pc, #104]	; (8000c98 <chSchGoSleepTimeoutS+0x108>)
 8000c2e:	f7ff ff97 	bl	8000b60 <chSchGoSleepS>
  return currp->u.rdymsg;
 8000c32:	69a3      	ldr	r3, [r4, #24]
}
 8000c34:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8000c36:	b007      	add	sp, #28
 8000c38:	bdf0      	pop	{r4, r5, r6, r7, pc}

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 8000c3a:	9b01      	ldr	r3, [sp, #4]
 8000c3c:	61e3      	str	r3, [r4, #28]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
  vtp->func = NULL;
 8000c3e:	2200      	movs	r2, #0

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8000c40:	42b3      	cmp	r3, r6
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8000c42:	605e      	str	r6, [r3, #4]
  vtp->func = NULL;
 8000c44:	9204      	str	r2, [sp, #16]
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8000c46:	d022      	beq.n	8000c8e <chSchGoSleepTimeoutS+0xfe>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 8000c48:	689a      	ldr	r2, [r3, #8]
 8000c4a:	9803      	ldr	r0, [sp, #12]
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX());
 8000c4c:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  ch.vtlist.next->delta += vtp->delta;
 8000c4e:	4402      	add	r2, r0
  return (systime_t)STM32_ST_TIM->CNT;
 8000c50:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8000c54:	609a      	str	r2, [r3, #8]
 8000c56:	6a43      	ldr	r3, [r0, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
 8000c58:	1a58      	subs	r0, r3, r1

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 8000c5a:	4282      	cmp	r2, r0
 8000c5c:	d9dc      	bls.n	8000c18 <chSchGoSleepTimeoutS+0x88>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
 8000c5e:	1acb      	subs	r3, r1, r3
 8000c60:	4413      	add	r3, r2

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 8000c62:	2b01      	cmp	r3, #1
    delta = nowdelta + (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8000c64:	bf98      	it	ls
 8000c66:	1c82      	addls	r2, r0, #2
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8000c68:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  return systime + (systime_t)interval;
 8000c6c:	440a      	add	r2, r1
 8000c6e:	635a      	str	r2, [r3, #52]	; 0x34
 8000c70:	e7d2      	b.n	8000c18 <chSchGoSleepTimeoutS+0x88>
 8000c72:	188b      	adds	r3, r1, r2
      ch.vtlist.next = vtp;
 8000c74:	af01      	add	r7, sp, #4
      ch.vtlist.lasttime = now;
 8000c76:	62a2      	str	r2, [r4, #40]	; 0x28
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 8000c78:	e9cd 6601 	strd	r6, r6, [sp, #4]
      ch.vtlist.prev = vtp;
 8000c7c:	e9c4 7707 	strd	r7, r7, [r4, #28]
      vtp->delta = delay;
 8000c80:	9103      	str	r1, [sp, #12]
  STM32_ST_TIM->SR     = 0;
 8000c82:	2200      	movs	r2, #0
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8000c84:	6343      	str	r3, [r0, #52]	; 0x34
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8000c86:	2302      	movs	r3, #2
  STM32_ST_TIM->SR     = 0;
 8000c88:	6102      	str	r2, [r0, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8000c8a:	60c3      	str	r3, [r0, #12]
 8000c8c:	e7b1      	b.n	8000bf2 <chSchGoSleepTimeoutS+0x62>
  STM32_ST_TIM->DIER = 0U;
 8000c8e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000c92:	60da      	str	r2, [r3, #12]
    return;
 8000c94:	e7c0      	b.n	8000c18 <chSchGoSleepTimeoutS+0x88>
 8000c96:	bf00      	nop
 8000c98:	20000d18 	.word	0x20000d18
 8000c9c:	08000711 	.word	0x08000711

08000ca0 <chThdEnqueueTimeoutS>:
  if (TIME_IMMEDIATE == timeout) {
 8000ca0:	b169      	cbz	r1, 8000cbe <chThdEnqueueTimeoutS+0x1e>
  queue_insert(currp, tqp);
 8000ca2:	4a08      	ldr	r2, [pc, #32]	; (8000cc4 <chThdEnqueueTimeoutS+0x24>)
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {
 8000ca4:	b410      	push	{r4}
  queue_insert(currp, tqp);
 8000ca6:	6992      	ldr	r2, [r2, #24]
  tp->queue.prev             = tqp->prev;
 8000ca8:	6844      	ldr	r4, [r0, #4]
 8000caa:	4603      	mov	r3, r0
 8000cac:	e9c2 3400 	strd	r3, r4, [r2]
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8000cb0:	2004      	movs	r0, #4
  tp->queue.prev->queue.next = tp;
 8000cb2:	6022      	str	r2, [r4, #0]
}
 8000cb4:	f85d 4b04 	ldr.w	r4, [sp], #4
  tqp->prev                  = tp;
 8000cb8:	605a      	str	r2, [r3, #4]
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8000cba:	f7ff bf69 	b.w	8000b90 <chSchGoSleepTimeoutS>
}
 8000cbe:	f04f 30ff 	mov.w	r0, #4294967295
 8000cc2:	4770      	bx	lr
 8000cc4:	20000d18 	.word	0x20000d18
	...

08000cd0 <oqPutTimeout>:
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, sysinterval_t timeout) {
 8000cd0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000cd2:	4604      	mov	r4, r0
 8000cd4:	460f      	mov	r7, r1
 8000cd6:	4616      	mov	r6, r2
 8000cd8:	2320      	movs	r3, #32
 8000cda:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8000cde:	e003      	b.n	8000ce8 <oqPutTimeout+0x18>
  return chThdEnqueueTimeoutS(tqp, timeout);
 8000ce0:	f7ff ffde 	bl	8000ca0 <chThdEnqueueTimeoutS>
    if (msg < MSG_OK) {
 8000ce4:	2800      	cmp	r0, #0
 8000ce6:	db18      	blt.n	8000d1a <oqPutTimeout+0x4a>
  while (oqIsFullI(oqp)) {
 8000ce8:	68a5      	ldr	r5, [r4, #8]
 8000cea:	4631      	mov	r1, r6
 8000cec:	4620      	mov	r0, r4
 8000cee:	2d00      	cmp	r5, #0
 8000cf0:	d0f6      	beq.n	8000ce0 <oqPutTimeout+0x10>
  *oqp->q_wrptr++ = b;
 8000cf2:	6962      	ldr	r2, [r4, #20]
  oqp->q_counter--;
 8000cf4:	68a3      	ldr	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8000cf6:	1c51      	adds	r1, r2, #1
  oqp->q_counter--;
 8000cf8:	3b01      	subs	r3, #1
  *oqp->q_wrptr++ = b;
 8000cfa:	6161      	str	r1, [r4, #20]
  oqp->q_counter--;
 8000cfc:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8000cfe:	7017      	strb	r7, [r2, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8000d00:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
 8000d04:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 8000d06:	bf24      	itt	cs
 8000d08:	68e3      	ldrcs	r3, [r4, #12]
 8000d0a:	6163      	strcs	r3, [r4, #20]
  if (oqp->q_notify != NULL) {
 8000d0c:	69e3      	ldr	r3, [r4, #28]
 8000d0e:	b103      	cbz	r3, 8000d12 <oqPutTimeout+0x42>
    oqp->q_notify(oqp);
 8000d10:	4798      	blx	r3
 8000d12:	2000      	movs	r0, #0
 8000d14:	f380 8811 	msr	BASEPRI, r0
}
 8000d18:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000d1a:	f385 8811 	msr	BASEPRI, r5
 8000d1e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08000d20 <_putt>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8000d20:	3030      	adds	r0, #48	; 0x30
 8000d22:	f7ff bfd5 	b.w	8000cd0 <oqPutTimeout>
 8000d26:	bf00      	nop
	...

08000d30 <_put>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8000d30:	3030      	adds	r0, #48	; 0x30
 8000d32:	f04f 32ff 	mov.w	r2, #4294967295
 8000d36:	f7ff bfcb 	b.w	8000cd0 <oqPutTimeout>
 8000d3a:	bf00      	nop
 8000d3c:	0000      	movs	r0, r0
	...

08000d40 <iqGetTimeout>:
msg_t iqGetTimeout(input_queue_t *iqp, sysinterval_t timeout) {
 8000d40:	b570      	push	{r4, r5, r6, lr}
 8000d42:	2320      	movs	r3, #32
 8000d44:	4605      	mov	r5, r0
 8000d46:	460e      	mov	r6, r1
 8000d48:	f383 8811 	msr	BASEPRI, r3
 8000d4c:	e003      	b.n	8000d56 <iqGetTimeout+0x16>
 8000d4e:	f7ff ffa7 	bl	8000ca0 <chThdEnqueueTimeoutS>
    if (msg < MSG_OK) {
 8000d52:	2800      	cmp	r0, #0
 8000d54:	db1a      	blt.n	8000d8c <iqGetTimeout+0x4c>
  while (iqIsEmptyI(iqp)) {
 8000d56:	68ac      	ldr	r4, [r5, #8]
 8000d58:	4631      	mov	r1, r6
 8000d5a:	4628      	mov	r0, r5
 8000d5c:	2c00      	cmp	r4, #0
 8000d5e:	d0f6      	beq.n	8000d4e <iqGetTimeout+0xe>
  b = *iqp->q_rdptr++;
 8000d60:	69a9      	ldr	r1, [r5, #24]
  iqp->q_counter--;
 8000d62:	68ab      	ldr	r3, [r5, #8]
  if (iqp->q_rdptr >= iqp->q_top) {
 8000d64:	6928      	ldr	r0, [r5, #16]
  b = *iqp->q_rdptr++;
 8000d66:	1c4a      	adds	r2, r1, #1
  iqp->q_counter--;
 8000d68:	3b01      	subs	r3, #1
  if (iqp->q_rdptr >= iqp->q_top) {
 8000d6a:	4282      	cmp	r2, r0
  iqp->q_counter--;
 8000d6c:	60ab      	str	r3, [r5, #8]
  b = *iqp->q_rdptr++;
 8000d6e:	61aa      	str	r2, [r5, #24]
    iqp->q_rdptr = iqp->q_buffer;
 8000d70:	bf28      	it	cs
 8000d72:	68eb      	ldrcs	r3, [r5, #12]
  b = *iqp->q_rdptr++;
 8000d74:	780c      	ldrb	r4, [r1, #0]
    iqp->q_rdptr = iqp->q_buffer;
 8000d76:	bf28      	it	cs
 8000d78:	61ab      	strcs	r3, [r5, #24]
  if (iqp->q_notify != NULL) {
 8000d7a:	69eb      	ldr	r3, [r5, #28]
 8000d7c:	b10b      	cbz	r3, 8000d82 <iqGetTimeout+0x42>
    iqp->q_notify(iqp);
 8000d7e:	4628      	mov	r0, r5
 8000d80:	4798      	blx	r3
 8000d82:	2300      	movs	r3, #0
 8000d84:	f383 8811 	msr	BASEPRI, r3
  return (msg_t)b;
 8000d88:	4620      	mov	r0, r4
}
 8000d8a:	bd70      	pop	{r4, r5, r6, pc}
 8000d8c:	f384 8811 	msr	BASEPRI, r4
 8000d90:	bd70      	pop	{r4, r5, r6, pc}
 8000d92:	bf00      	nop
	...

08000da0 <_gett>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8000da0:	300c      	adds	r0, #12
 8000da2:	f7ff bfcd 	b.w	8000d40 <iqGetTimeout>
 8000da6:	bf00      	nop
	...

08000db0 <_get>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8000db0:	300c      	adds	r0, #12
 8000db2:	f04f 31ff 	mov.w	r1, #4294967295
 8000db6:	f7ff bfc3 	b.w	8000d40 <iqGetTimeout>
 8000dba:	bf00      	nop
 8000dbc:	0000      	movs	r0, r0
	...

08000dc0 <chThdSleep>:
void chThdSleep(sysinterval_t time) {
 8000dc0:	b508      	push	{r3, lr}
 8000dc2:	4601      	mov	r1, r0
 8000dc4:	2320      	movs	r3, #32
 8000dc6:	f383 8811 	msr	BASEPRI, r3
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 8000dca:	2008      	movs	r0, #8
 8000dcc:	f7ff fee0 	bl	8000b90 <chSchGoSleepTimeoutS>
 8000dd0:	2300      	movs	r3, #0
 8000dd2:	f383 8811 	msr	BASEPRI, r3
}
 8000dd6:	bd08      	pop	{r3, pc}
	...

08000de0 <Thread1>:
  /* USER CODE END 3 */

}

static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg) {
 8000de0:	b508      	push	{r3, lr}
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
 8000de2:	4b09      	ldr	r3, [pc, #36]	; (8000e08 <Thread1+0x28>)
 8000de4:	4a09      	ldr	r2, [pc, #36]	; (8000e0c <Thread1+0x2c>)
 8000de6:	699b      	ldr	r3, [r3, #24]


  (void)arg;
  chRegSetThreadName("blinker");
  while (true) {
    palSetPad(GPIOD, GPIOD_LED3); /* Orange.  */
 8000de8:	4c09      	ldr	r4, [pc, #36]	; (8000e10 <Thread1+0x30>)
 8000dea:	619a      	str	r2, [r3, #24]
 8000dec:	f44f 5500 	mov.w	r5, #8192	; 0x2000
 8000df0:	462e      	mov	r6, r5
 8000df2:	8326      	strh	r6, [r4, #24]
    chThdSleepMilliseconds(500);
 8000df4:	f241 3088 	movw	r0, #5000	; 0x1388
 8000df8:	f7ff ffe2 	bl	8000dc0 <chThdSleep>
    palClearPad(GPIOD, GPIOD_LED3); /* Orange.  */
 8000dfc:	8365      	strh	r5, [r4, #26]
    chThdSleepMilliseconds(500);
 8000dfe:	f241 3088 	movw	r0, #5000	; 0x1388
 8000e02:	f7ff ffdd 	bl	8000dc0 <chThdSleep>
  while (true) {
 8000e06:	e7f4      	b.n	8000df2 <Thread1+0x12>
 8000e08:	20000d18 	.word	0x20000d18
 8000e0c:	080024b8 	.word	0x080024b8
 8000e10:	40020c00 	.word	0x40020c00
	...

08000e20 <mp45dt02ProcessingThd>:
{
 8000e20:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000e24:	4bce      	ldr	r3, [pc, #824]	; (8001160 <mp45dt02ProcessingThd+0x340>)
 8000e26:	4acf      	ldr	r2, [pc, #828]	; (8001164 <mp45dt02ProcessingThd+0x344>)
 8000e28:	699b      	ldr	r3, [r3, #24]
 8000e2a:	ed2d 8b0a 	vpush	{d8-d12}
            outBuffer[bitIndex] = INT16_MIN;
 8000e2e:	ed9f 8ace 	vldr	s16, [pc, #824]	; 8001168 <mp45dt02ProcessingThd+0x348>
            outBuffer[bitIndex] = INT16_MAX;
 8000e32:	eddf 8ace 	vldr	s17, [pc, #824]	; 800116c <mp45dt02ProcessingThd+0x34c>
 8000e36:	619a      	str	r2, [r3, #24]
{
 8000e38:	b099      	sub	sp, #100	; 0x64
 8000e3a:	2320      	movs	r3, #32
 8000e3c:	f383 8811 	msr	BASEPRI, r3
  if (--sp->cnt < (cnt_t)0) {
 8000e40:	4acb      	ldr	r2, [pc, #812]	; (8001170 <mp45dt02ProcessingThd+0x350>)
 8000e42:	6893      	ldr	r3, [r2, #8]
 8000e44:	3b01      	subs	r3, #1
 8000e46:	2b00      	cmp	r3, #0
 8000e48:	6093      	str	r3, [r2, #8]
 8000e4a:	f2c0 8222 	blt.w	8001292 <mp45dt02ProcessingThd+0x472>
 8000e4e:	2300      	movs	r3, #0
 8000e50:	f383 8811 	msr	BASEPRI, r3
  return (bool)((chThdGetSelfX()->flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 8000e54:	4bc2      	ldr	r3, [pc, #776]	; (8001160 <mp45dt02ProcessingThd+0x340>)
 8000e56:	699b      	ldr	r3, [r3, #24]
        if (chThdShouldTerminateX())
 8000e58:	f893 2021 	ldrb.w	r2, [r3, #33]	; 0x21
 8000e5c:	f012 0204 	ands.w	r2, r2, #4
 8000e60:	f040 82cb 	bne.w	80013fa <mp45dt02ProcessingThd+0x5da>
        chTMStartMeasurementX(&debugTimings.totalProcessing);
 8000e64:	48c3      	ldr	r0, [pc, #780]	; (8001174 <mp45dt02ProcessingThd+0x354>)
               &mp45dt02I2sData.buffer[mp45dt02I2sData.offset]);
 8000e66:	f8df 8328 	ldr.w	r8, [pc, #808]	; 8001190 <mp45dt02ProcessingThd+0x370>
        chTMStartMeasurementX(&debugTimings.totalProcessing);
 8000e6a:	f7ff fc49 	bl	8000700 <chTMStartMeasurementX>
        chTMStartMeasurementX(&debugTimings.expansion);
 8000e6e:	48c2      	ldr	r0, [pc, #776]	; (8001178 <mp45dt02ProcessingThd+0x358>)
 8000e70:	f7ff fc46 	bl	8000700 <chTMStartMeasurementX>
        expand(mp45dt02ExpandedBuffer,
 8000e74:	f8d8 0000 	ldr.w	r0, [r8]
 8000e78:	4bc0      	ldr	r3, [pc, #768]	; (800117c <mp45dt02ProcessingThd+0x35c>)
 8000e7a:	3004      	adds	r0, #4
    memset(outBuffer, 0, sizeof(MP45DT02_EXPANDED_BUFFER_SIZE));
 8000e7c:	601a      	str	r2, [r3, #0]
    for(bitIndex=0;
 8000e7e:	4614      	mov	r4, r2
            modifiedCurrentWord = inBuffer[bitIndex/MP45DT02_I2S_WORD_SIZE_BITS];
 8000e80:	eb00 1114 	add.w	r1, r0, r4, lsr #4
        if (bitIndex % 16 == 0)
 8000e84:	f014 0f0f 	tst.w	r4, #15
            modifiedCurrentWord = inBuffer[bitIndex/MP45DT02_I2S_WORD_SIZE_BITS];
 8000e88:	bf08      	it	eq
 8000e8a:	f838 2011 	ldrheq.w	r2, [r8, r1, lsl #1]
        bitIndex++)
 8000e8e:	3401      	adds	r4, #1
        if (modifiedCurrentWord & 0x8000)
 8000e90:	0417      	lsls	r7, r2, #16
            outBuffer[bitIndex] = INT16_MAX;
 8000e92:	bf4c      	ite	mi
 8000e94:	edc3 8a00 	vstrmi	s17, [r3]
            outBuffer[bitIndex] = INT16_MIN;
 8000e98:	ed83 8a00 	vstrpl	s16, [r3]
        modifiedCurrentWord = modifiedCurrentWord << 1;
 8000e9c:	0052      	lsls	r2, r2, #1
    for(bitIndex=0;
 8000e9e:	f5b4 6f80 	cmp.w	r4, #1024	; 0x400
        modifiedCurrentWord = modifiedCurrentWord << 1;
 8000ea2:	b292      	uxth	r2, r2
 8000ea4:	f103 0304 	add.w	r3, r3, #4
    for(bitIndex=0;
 8000ea8:	d1ea      	bne.n	8000e80 <mp45dt02ProcessingThd+0x60>
        chTMStopMeasurementX(&debugTimings.expansion);
 8000eaa:	48b3      	ldr	r0, [pc, #716]	; (8001178 <mp45dt02ProcessingThd+0x358>)
      tapCnt--;
    }

    /* Advance the state pointer by the decimation factor
     * to process the next group of decimation factor number samples */
    pState = pState + 4 * S->M;
 8000eac:	f8df b2cc 	ldr.w	fp, [pc, #716]	; 800117c <mp45dt02ProcessingThd+0x35c>
 8000eb0:	f7ff fbfe 	bl	80006b0 <chTMStopMeasurementX>
        chTMStartMeasurementX(&debugTimings.decimate);
 8000eb4:	48b2      	ldr	r0, [pc, #712]	; (8001180 <mp45dt02ProcessingThd+0x360>)
 8000eb6:	f7ff fc23 	bl	8000700 <chTMStartMeasurementX>
  float32_t *pState = S->pState;                 /* State pointer */
 8000eba:	4bb2      	ldr	r3, [pc, #712]	; (8001184 <mp45dt02ProcessingThd+0x364>)
                             &output.buffer[output.count * MP45DT02_DECIMATED_BUFFER_SIZE],
 8000ebc:	49b2      	ldr	r1, [pc, #712]	; (8001188 <mp45dt02ProcessingThd+0x368>)
  uint32_t numTaps = S->numTaps;                 /* Number of filter coefficients in the filter */
 8000ebe:	885d      	ldrh	r5, [r3, #2]
 8000ec0:	680a      	ldr	r2, [r1, #0]
  float32_t *pState = S->pState;                 /* State pointer */
 8000ec2:	689e      	ldr	r6, [r3, #8]
  pStateCurnt = S->pState + (numTaps - 1U);
 8000ec4:	9512      	str	r5, [sp, #72]	; 0x48
 8000ec6:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
 8000eca:	3d01      	subs	r5, #1
  uint32_t i, tapCnt, blkCnt, outBlockSize = blockSize / S->M;  /* Loop counters */
 8000ecc:	7818      	ldrb	r0, [r3, #0]
  float32_t *pCoeffs = S->pCoeffs;               /* Coefficient pointer */
 8000ece:	685f      	ldr	r7, [r3, #4]
  uint32_t i, tapCnt, blkCnt, outBlockSize = blockSize / S->M;  /* Loop counters */
 8000ed0:	fbb4 f3f0 	udiv	r3, r4, r0
        arm_fir_decimate_f32(&cmsisDsp.decimateInstance,
 8000ed4:	eb01 1c82 	add.w	ip, r1, r2, lsl #6
  blkCnt = outBlockSize / 4;
 8000ed8:	089c      	lsrs	r4, r3, #2
  pStateCurnt = S->pState + (numTaps - 1U);
 8000eda:	eb06 0285 	add.w	r2, r6, r5, lsl #2
 8000ede:	9213      	str	r2, [sp, #76]	; 0x4c
  blkCnt = outBlockSize / 4;
 8000ee0:	9415      	str	r4, [sp, #84]	; 0x54
 8000ee2:	1c62      	adds	r2, r4, #1
 8000ee4:	f003 0303 	and.w	r3, r3, #3
 8000ee8:	f10c 0404 	add.w	r4, ip, #4
 8000eec:	9411      	str	r4, [sp, #68]	; 0x44
 8000eee:	9314      	str	r3, [sp, #80]	; 0x50
    px3 = pState + 3 * S->M;
 8000ef0:	eb00 0140 	add.w	r1, r0, r0, lsl #1
 8000ef4:	0113      	lsls	r3, r2, #4
 8000ef6:	0089      	lsls	r1, r1, #2
 8000ef8:	9316      	str	r3, [sp, #88]	; 0x58
 8000efa:	9b11      	ldr	r3, [sp, #68]	; 0x44
    tapCnt = numTaps >> 2;
 8000efc:	9d12      	ldr	r5, [sp, #72]	; 0x48
    px3 = pState + 3 * S->M;
 8000efe:	9105      	str	r1, [sp, #20]
 8000f00:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8000f04:	9a05      	ldr	r2, [sp, #20]
 8000f06:	9710      	str	r7, [sp, #64]	; 0x40
    tapCnt = numTaps >> 2;
 8000f08:	08a9      	lsrs	r1, r5, #2
 8000f0a:	3710      	adds	r7, #16
 8000f0c:	9307      	str	r3, [sp, #28]
 8000f0e:	eb02 1301 	add.w	r3, r2, r1, lsl #4
 8000f12:	9702      	str	r7, [sp, #8]
 8000f14:	930b      	str	r3, [sp, #44]	; 0x2c
    px2 = pState + 2 * S->M;
 8000f16:	00c7      	lsls	r7, r0, #3
 8000f18:	f102 0310 	add.w	r3, r2, #16
 8000f1c:	9704      	str	r7, [sp, #16]
 8000f1e:	010a      	lsls	r2, r1, #4
 8000f20:	9c10      	ldr	r4, [sp, #64]	; 0x40
    tapCnt = numTaps >> 2;
 8000f22:	9101      	str	r1, [sp, #4]
 8000f24:	930e      	str	r3, [sp, #56]	; 0x38
 8000f26:	460b      	mov	r3, r1
 8000f28:	9902      	ldr	r1, [sp, #8]
 8000f2a:	9208      	str	r2, [sp, #32]
 8000f2c:	9a04      	ldr	r2, [sp, #16]
  pStateCurnt = S->pState + (numTaps - 1U);
 8000f2e:	f8dd a04c 	ldr.w	sl, [sp, #76]	; 0x4c
  uint32_t i, tapCnt, blkCnt, outBlockSize = blockSize / S->M;  /* Loop counters */
 8000f32:	9017      	str	r0, [sp, #92]	; 0x5c
    i = 4 * S->M;
 8000f34:	ea4f 0980 	mov.w	r9, r0, lsl #2
 8000f38:	eb01 1703 	add.w	r7, r1, r3, lsl #4
 8000f3c:	eb04 1103 	add.w	r1, r4, r3, lsl #4
 8000f40:	9103      	str	r1, [sp, #12]
 8000f42:	eb09 1103 	add.w	r1, r9, r3, lsl #4
 8000f46:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 8000f4a:	930a      	str	r3, [sp, #40]	; 0x28
 8000f4c:	f109 0310 	add.w	r3, r9, #16
  float32_t *pState = S->pState;                 /* State pointer */
 8000f50:	960f      	str	r6, [sp, #60]	; 0x3c
void arm_fir_decimate_f32(
 8000f52:	9109      	str	r1, [sp, #36]	; 0x24
 8000f54:	930c      	str	r3, [sp, #48]	; 0x30
 8000f56:	f102 0310 	add.w	r3, r2, #16
 8000f5a:	930d      	str	r3, [sp, #52]	; 0x34
 8000f5c:	f005 0303 	and.w	r3, r5, #3
 8000f60:	f10c 0c14 	add.w	ip, ip, #20
    pState = pState + 4 * S->M;
 8000f64:	ea4f 1e00 	mov.w	lr, r0, lsl #4
 8000f68:	9306      	str	r3, [sp, #24]
 8000f6a:	4651      	mov	r1, sl
    i = 4 * S->M;
 8000f6c:	464b      	mov	r3, r9
 8000f6e:	465a      	mov	r2, fp
      *pStateCurnt++ = *pSrc++;
 8000f70:	f852 0b04 	ldr.w	r0, [r2], #4
 8000f74:	f841 0b04 	str.w	r0, [r1], #4
    } while (--i);
 8000f78:	3b01      	subs	r3, #1
 8000f7a:	d1f9      	bne.n	8000f70 <mp45dt02ProcessingThd+0x150>
 8000f7c:	9b04      	ldr	r3, [sp, #16]
    acc3 = 0.0f;
 8000f7e:	eddf 7a83 	vldr	s15, [pc, #524]	; 800118c <mp45dt02ProcessingThd+0x36c>
 8000f82:	1999      	adds	r1, r3, r6
 8000f84:	9b05      	ldr	r3, [sp, #20]
 8000f86:	18f0      	adds	r0, r6, r3
    while (tapCnt > 0U)
 8000f88:	9b01      	ldr	r3, [sp, #4]
 8000f8a:	44f3      	add	fp, lr
 8000f8c:	44f2      	add	sl, lr
 8000f8e:	eb06 0209 	add.w	r2, r6, r9
    acc2 = 0.0f;
 8000f92:	eeb0 7a67 	vmov.f32	s14, s15
    acc1 = 0.0f;
 8000f96:	eef0 6a67 	vmov.f32	s13, s15
    acc0 = 0.0f;
 8000f9a:	eeb0 6a67 	vmov.f32	s12, s15
    while (tapCnt > 0U)
 8000f9e:	2b00      	cmp	r3, #0
 8000fa0:	f000 8171 	beq.w	8001286 <mp45dt02ProcessingThd+0x466>
 8000fa4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8000fa6:	9b02      	ldr	r3, [sp, #8]
 8000fa8:	1990      	adds	r0, r2, r6
 8000faa:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8000fac:	1991      	adds	r1, r2, r6
 8000fae:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8000fb0:	f106 0410 	add.w	r4, r6, #16
 8000fb4:	4432      	add	r2, r6
      c0 = *(pb++);
 8000fb6:	ed13 4a04 	vldr	s8, [r3, #-16]
      acc0 += x0 * c0;
 8000fba:	ed54 ca04 	vldr	s25, [r4, #-16]
      acc1 += x1 * c0;
 8000fbe:	ed10 ca04 	vldr	s24, [r0, #-16]
      acc2 += x2 * c0;
 8000fc2:	ed51 ba04 	vldr	s23, [r1, #-16]
      acc3 += x3 * c0;
 8000fc6:	ed12 ba04 	vldr	s22, [r2, #-16]
      c0 = *(pb++);
 8000fca:	ed53 4a03 	vldr	s9, [r3, #-12]
      acc0 += x0 * c0;
 8000fce:	ed54 aa03 	vldr	s21, [r4, #-12]
      acc1 += x1 * c0;
 8000fd2:	ed10 aa03 	vldr	s20, [r0, #-12]
      acc2 += x2 * c0;
 8000fd6:	ed51 9a03 	vldr	s19, [r1, #-12]
      acc3 += x3 * c0;
 8000fda:	ed12 9a03 	vldr	s18, [r2, #-12]
      c0 = *(pb++);
 8000fde:	ed13 5a02 	vldr	s10, [r3, #-8]
      acc0 += x0 * c0;
 8000fe2:	ed14 0a02 	vldr	s0, [r4, #-8]
      acc1 += x1 * c0;
 8000fe6:	ed50 0a02 	vldr	s1, [r0, #-8]
      acc2 += x2 * c0;
 8000fea:	ed11 1a02 	vldr	s2, [r1, #-8]
      acc3 += x3 * c0;
 8000fee:	ed52 1a02 	vldr	s3, [r2, #-8]
      c0 = *(pb++);
 8000ff2:	ed53 5a01 	vldr	s11, [r3, #-4]
      acc0 += x0 * c0;
 8000ff6:	ed14 2a01 	vldr	s4, [r4, #-4]
      acc1 += x1 * c0;
 8000ffa:	ed50 2a01 	vldr	s5, [r0, #-4]
      acc2 += x2 * c0;
 8000ffe:	ed11 3a01 	vldr	s6, [r1, #-4]
      acc3 += x3 * c0;
 8001002:	ed52 3a01 	vldr	s7, [r2, #-4]
      acc0 += x0 * c0;
 8001006:	eea4 6a2c 	vfma.f32	s12, s8, s25
 800100a:	3310      	adds	r3, #16
    while (tapCnt > 0U)
 800100c:	42bb      	cmp	r3, r7
      acc1 += x1 * c0;
 800100e:	eee4 6a0c 	vfma.f32	s13, s8, s24
 8001012:	f104 0410 	add.w	r4, r4, #16
 8001016:	f100 0010 	add.w	r0, r0, #16
      acc2 += x2 * c0;
 800101a:	eea4 7a2b 	vfma.f32	s14, s8, s23
 800101e:	f101 0110 	add.w	r1, r1, #16
 8001022:	f102 0210 	add.w	r2, r2, #16
      acc3 += x3 * c0;
 8001026:	eee4 7a0b 	vfma.f32	s15, s8, s22
      acc0 += x0 * c0;
 800102a:	eea4 6aaa 	vfma.f32	s12, s9, s21
      acc1 += x1 * c0;
 800102e:	eee4 6a8a 	vfma.f32	s13, s9, s20
      acc2 += x2 * c0;
 8001032:	eea4 7aa9 	vfma.f32	s14, s9, s19
      acc3 += x3 * c0;
 8001036:	eee4 7a89 	vfma.f32	s15, s9, s18
      acc0 += x0 * c0;
 800103a:	eea5 6a00 	vfma.f32	s12, s10, s0
      acc1 += x1 * c0;
 800103e:	eee5 6a20 	vfma.f32	s13, s10, s1
      acc2 += x2 * c0;
 8001042:	eea5 7a01 	vfma.f32	s14, s10, s2
      acc3 += x3 * c0;
 8001046:	eee5 7a21 	vfma.f32	s15, s10, s3
      acc0 += x0 * c0;
 800104a:	eea5 6a82 	vfma.f32	s12, s11, s4
      acc1 += x1 * c0;
 800104e:	eee5 6aa2 	vfma.f32	s13, s11, s5
      acc2 += x2 * c0;
 8001052:	eea5 7a83 	vfma.f32	s14, s11, s6
      acc3 += x3 * c0;
 8001056:	eee5 7aa3 	vfma.f32	s15, s11, s7
    while (tapCnt > 0U)
 800105a:	d1ac      	bne.n	8000fb6 <mp45dt02ProcessingThd+0x196>
 800105c:	9b08      	ldr	r3, [sp, #32]
      c0 = *(pb++);
 800105e:	9c03      	ldr	r4, [sp, #12]
 8001060:	18f5      	adds	r5, r6, r3
 8001062:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8001064:	18f2      	adds	r2, r6, r3
 8001066:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8001068:	18f1      	adds	r1, r6, r3
 800106a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800106c:	18f0      	adds	r0, r6, r3
    while (tapCnt > 0U)
 800106e:	9b06      	ldr	r3, [sp, #24]
 8001070:	b19b      	cbz	r3, 800109a <mp45dt02ProcessingThd+0x27a>
      c0 = *(pb++);
 8001072:	ecf4 5a01 	vldmia	r4!, {s11}
      acc0 += x0 * c0;
 8001076:	ecf5 3a01 	vldmia	r5!, {s7}
      acc1 += x1 * c0;
 800107a:	ecb2 4a01 	vldmia	r2!, {s8}
      acc2 += x2 * c0;
 800107e:	ecf1 4a01 	vldmia	r1!, {s9}
      acc3 += x3 * c0;
 8001082:	ecb0 5a01 	vldmia	r0!, {s10}
    while (tapCnt > 0U)
 8001086:	3b01      	subs	r3, #1
      acc0 += x0 * c0;
 8001088:	eea5 6aa3 	vfma.f32	s12, s11, s7
      acc1 += x1 * c0;
 800108c:	eee5 6a84 	vfma.f32	s13, s11, s8
      acc2 += x2 * c0;
 8001090:	eea5 7aa4 	vfma.f32	s14, s11, s9
      acc3 += x3 * c0;
 8001094:	eee5 7a85 	vfma.f32	s15, s11, s10
    while (tapCnt > 0U)
 8001098:	d1eb      	bne.n	8001072 <mp45dt02ProcessingThd+0x252>
  while (blkCnt > 0U)
 800109a:	9b07      	ldr	r3, [sp, #28]

    /* The result is in the accumulator, store in the destination buffer. */
    *pDst++ = acc0;
 800109c:	ed0c 6a04 	vstr	s12, [ip, #-16]
    *pDst++ = acc1;
 80010a0:	ed4c 6a03 	vstr	s13, [ip, #-12]
    *pDst++ = acc2;
 80010a4:	ed0c 7a02 	vstr	s14, [ip, #-8]
    *pDst++ = acc3;
 80010a8:	ed4c 7a01 	vstr	s15, [ip, #-4]
 80010ac:	f10c 0c10 	add.w	ip, ip, #16
  while (blkCnt > 0U)
 80010b0:	459c      	cmp	ip, r3
    pState = pState + 4 * S->M;
 80010b2:	4476      	add	r6, lr
  while (blkCnt > 0U)
 80010b4:	f47f af59 	bne.w	8000f6a <mp45dt02ProcessingThd+0x14a>
 80010b8:	9b16      	ldr	r3, [sp, #88]	; 0x58
 80010ba:	9a11      	ldr	r2, [sp, #68]	; 0x44
 80010bc:	f1a3 0110 	sub.w	r1, r3, #16
 80010c0:	440a      	add	r2, r1
 80010c2:	9b15      	ldr	r3, [sp, #84]	; 0x54
 80010c4:	4611      	mov	r1, r2
 80010c6:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 80010c8:	fb09 f003 	mul.w	r0, r9, r3
 80010cc:	fb0e 2e03 	mla	lr, lr, r3, r2
 80010d0:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80010d2:	eb03 0580 	add.w	r5, r3, r0, lsl #2
 80010d6:	4b29      	ldr	r3, [pc, #164]	; (800117c <mp45dt02ProcessingThd+0x35c>)
 80010d8:	eb03 0080 	add.w	r0, r3, r0, lsl #2

    /* Decrement the loop counter */
    blkCnt--;
  }

  while (blkCntN4 > 0U)
 80010dc:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80010de:	2b00      	cmp	r3, #0
 80010e0:	d06c      	beq.n	80011bc <mp45dt02ProcessingThd+0x39c>
    pState = pState + 4 * S->M;
 80010e2:	4674      	mov	r4, lr
 80010e4:	f8cd e010 	str.w	lr, [sp, #16]
 80010e8:	f8dd a05c 	ldr.w	sl, [sp, #92]	; 0x5c
 80010ec:	f8dd e020 	ldr.w	lr, [sp, #32]
 80010f0:	9e06      	ldr	r6, [sp, #24]
 80010f2:	eb01 0c83 	add.w	ip, r1, r3, lsl #2
 80010f6:	46ab      	mov	fp, r5
  {
    /* Copy decimation factor number of new input samples into the state buffer */
    i = S->M;
 80010f8:	4653      	mov	r3, sl
 80010fa:	4602      	mov	r2, r0

    do
    {
      *pStateCurnt++ = *pSrc++;
 80010fc:	ecf2 7a01 	vldmia	r2!, {s15}

    } while (--i);
 8001100:	3b01      	subs	r3, #1
      *pStateCurnt++ = *pSrc++;
 8001102:	eceb 7a01 	vstmia	fp!, {s15}
    } while (--i);
 8001106:	d1f9      	bne.n	80010fc <mp45dt02ProcessingThd+0x2dc>
    /* Loop unrolling.  Process 4 taps at a time. */
    tapCnt = numTaps >> 2;

    /* Loop over the number of taps.  Unroll by a factor of 4.
     ** Repeat until we've computed numTaps-4 coefficients. */
    while (tapCnt > 0U)
 8001108:	9b01      	ldr	r3, [sp, #4]
    sum0 = 0.0f;
 800110a:	eddf 7a20 	vldr	s15, [pc, #128]	; 800118c <mp45dt02ProcessingThd+0x36c>
 800110e:	4448      	add	r0, r9
 8001110:	444d      	add	r5, r9
    while (tapCnt > 0U)
 8001112:	2b00      	cmp	r3, #0
 8001114:	f000 80ba 	beq.w	800128c <mp45dt02ProcessingThd+0x46c>
 8001118:	9b02      	ldr	r3, [sp, #8]
 800111a:	f104 0210 	add.w	r2, r4, #16

      /* Read x[n-numTaps-1] sample */
      x0 = *(px++);

      /* Perform the multiply-accumulate */
      sum0 += x0 * c0;
 800111e:	ed53 3a04 	vldr	s7, [r3, #-16]
 8001122:	ed12 4a04 	vldr	s8, [r2, #-16]

      /* Read x[n-numTaps-2] sample */
      x0 = *(px++);

      /* Perform the multiply-accumulate */
      sum0 += x0 * c0;
 8001126:	ed53 4a03 	vldr	s9, [r3, #-12]
 800112a:	ed12 5a03 	vldr	s10, [r2, #-12]

      /* Read x[n-numTaps-3] sample */
      x0 = *(px++);

      /* Perform the multiply-accumulate */
      sum0 += x0 * c0;
 800112e:	ed53 5a02 	vldr	s11, [r3, #-8]
 8001132:	ed12 6a02 	vldr	s12, [r2, #-8]

      /* Read x[n-numTaps-4] sample */
      x0 = *(px++);

      /* Perform the multiply-accumulate */
      sum0 += x0 * c0;
 8001136:	ed53 6a01 	vldr	s13, [r3, #-4]
 800113a:	ed12 7a01 	vldr	s14, [r2, #-4]
      sum0 += x0 * c0;
 800113e:	eee3 7a84 	vfma.f32	s15, s7, s8
 8001142:	3310      	adds	r3, #16
    while (tapCnt > 0U)
 8001144:	42bb      	cmp	r3, r7
 8001146:	f102 0210 	add.w	r2, r2, #16
      sum0 += x0 * c0;
 800114a:	eee4 7a85 	vfma.f32	s15, s9, s10
      sum0 += x0 * c0;
 800114e:	eee5 7a86 	vfma.f32	s15, s11, s12
      sum0 += x0 * c0;
 8001152:	eee6 7a87 	vfma.f32	s15, s13, s14
    while (tapCnt > 0U)
 8001156:	d1e2      	bne.n	800111e <mp45dt02ProcessingThd+0x2fe>
      c0 = *(pb++);
 8001158:	9a03      	ldr	r2, [sp, #12]
 800115a:	eb04 0b0e 	add.w	fp, r4, lr
 800115e:	e019      	b.n	8001194 <mp45dt02ProcessingThd+0x374>
 8001160:	20000d18 	.word	0x20000d18
 8001164:	080024c0 	.word	0x080024c0
 8001168:	c7000000 	.word	0xc7000000
 800116c:	46fffe00 	.word	0x46fffe00
 8001170:	20003588 	.word	0x20003588
 8001174:	20002398 	.word	0x20002398
 8001178:	20002368 	.word	0x20002368
 800117c:	20002468 	.word	0x20002468
 8001180:	20002350 	.word	0x20002350
 8001184:	20000f40 	.word	0x20000f40
 8001188:	200037e8 	.word	0x200037e8
 800118c:	00000000 	.word	0x00000000
 8001190:	2000347c 	.word	0x2000347c
    }

    /* If the filter length is not a multiple of 4, compute the remaining filter taps */
    tapCnt = numTaps % 0x4U;

    while (tapCnt > 0U)
 8001194:	b146      	cbz	r6, 80011a8 <mp45dt02ProcessingThd+0x388>
 8001196:	4633      	mov	r3, r6

      /* Fetch 1 state variable */
      x0 = *(px++);

      /* Perform the multiply-accumulate */
      sum0 += x0 * c0;
 8001198:	ecf2 6a01 	vldmia	r2!, {s13}
 800119c:	ecbb 7a01 	vldmia	fp!, {s14}
    while (tapCnt > 0U)
 80011a0:	3b01      	subs	r3, #1
      sum0 += x0 * c0;
 80011a2:	eee6 7a87 	vfma.f32	s15, s13, s14
    while (tapCnt > 0U)
 80011a6:	d1f7      	bne.n	8001198 <mp45dt02ProcessingThd+0x378>
    /* Advance the state pointer by the decimation factor
     * to process the next group of decimation factor number samples */
    pState = pState + S->M;

    /* The result is in the accumulator, store in the destination buffer. */
    *pDst++ = sum0;
 80011a8:	ece1 7a01 	vstmia	r1!, {s15}
  while (blkCntN4 > 0U)
 80011ac:	4561      	cmp	r1, ip
    pState = pState + S->M;
 80011ae:	444c      	add	r4, r9
  while (blkCntN4 > 0U)
 80011b0:	d1a1      	bne.n	80010f6 <mp45dt02ProcessingThd+0x2d6>
 80011b2:	f8dd e010 	ldr.w	lr, [sp, #16]
 80011b6:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80011b8:	fb09 ee03 	mla	lr, r9, r3, lr
   ** This prepares the state buffer for the next function call. */

  /* Points to the start of the state buffer */
  pStateCurnt = S->pState;

  i = (numTaps - 1U) >> 2;
 80011bc:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80011be:	1e5c      	subs	r4, r3, #1

  /* copy data */
  while (i > 0U)
 80011c0:	08a5      	lsrs	r5, r4, #2
 80011c2:	d020      	beq.n	8001206 <mp45dt02ProcessingThd+0x3e6>
 80011c4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80011c6:	f10e 0210 	add.w	r2, lr, #16
 80011ca:	3310      	adds	r3, #16
 80011cc:	4629      	mov	r1, r5
  {
    *pStateCurnt++ = *pState++;
 80011ce:	f852 0c10 	ldr.w	r0, [r2, #-16]
 80011d2:	f843 0c10 	str.w	r0, [r3, #-16]
    *pStateCurnt++ = *pState++;
 80011d6:	f852 0c0c 	ldr.w	r0, [r2, #-12]
 80011da:	f843 0c0c 	str.w	r0, [r3, #-12]
    *pStateCurnt++ = *pState++;
 80011de:	f852 0c08 	ldr.w	r0, [r2, #-8]
 80011e2:	f843 0c08 	str.w	r0, [r3, #-8]
    *pStateCurnt++ = *pState++;
 80011e6:	f852 0c04 	ldr.w	r0, [r2, #-4]
 80011ea:	f843 0c04 	str.w	r0, [r3, #-4]
  while (i > 0U)
 80011ee:	3901      	subs	r1, #1
 80011f0:	f102 0210 	add.w	r2, r2, #16
 80011f4:	f103 0310 	add.w	r3, r3, #16
 80011f8:	d1e9      	bne.n	80011ce <mp45dt02ProcessingThd+0x3ae>
 80011fa:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80011fc:	eb03 1305 	add.w	r3, r3, r5, lsl #4
 8001200:	eb0e 1e05 	add.w	lr, lr, r5, lsl #4
 8001204:	930f      	str	r3, [sp, #60]	; 0x3c
  }

  i = (numTaps - 1U) % 0x04U;

  /* copy data */
  while (i > 0U)
 8001206:	f014 0303 	ands.w	r3, r4, #3
 800120a:	d008      	beq.n	800121e <mp45dt02ProcessingThd+0x3fe>
 800120c:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800120e:	eb0e 0383 	add.w	r3, lr, r3, lsl #2
  {
    *pStateCurnt++ = *pState++;
 8001212:	f85e 1b04 	ldr.w	r1, [lr], #4
 8001216:	f842 1b04 	str.w	r1, [r2], #4
  while (i > 0U)
 800121a:	459e      	cmp	lr, r3
 800121c:	d1f9      	bne.n	8001212 <mp45dt02ProcessingThd+0x3f2>
        chTMStopMeasurementX(&debugTimings.decimate);
 800121e:	4879      	ldr	r0, [pc, #484]	; (8001404 <mp45dt02ProcessingThd+0x5e4>)
 8001220:	f7ff fa46 	bl	80006b0 <chTMStopMeasurementX>
        output.count++;
 8001224:	4a78      	ldr	r2, [pc, #480]	; (8001408 <mp45dt02ProcessingThd+0x5e8>)
        chTMStopMeasurementX(&debugTimings.totalProcessing);
 8001226:	4879      	ldr	r0, [pc, #484]	; (800140c <mp45dt02ProcessingThd+0x5ec>)
        output.count++;
 8001228:	6813      	ldr	r3, [r2, #0]
 800122a:	4614      	mov	r4, r2
 800122c:	3301      	adds	r3, #1
 800122e:	6013      	str	r3, [r2, #0]
        chTMStopMeasurementX(&debugTimings.totalProcessing);
 8001230:	f7ff fa3e 	bl	80006b0 <chTMStopMeasurementX>
        if (output.count == MP45DT02_OUTPUT_BUFFER_DURATION_MS / 
 8001234:	6823      	ldr	r3, [r4, #0]
 8001236:	f5b3 6fc8 	cmp.w	r3, #1600	; 0x640
 800123a:	d037      	beq.n	80012ac <mp45dt02ProcessingThd+0x48c>
        if (mp45dt02I2sData.guard != MEMORY_GUARD)
 800123c:	f8d8 3108 	ldr.w	r3, [r8, #264]	; 0x108
 8001240:	4a73      	ldr	r2, [pc, #460]	; (8001410 <mp45dt02ProcessingThd+0x5f0>)
 8001242:	4293      	cmp	r3, r2
 8001244:	f040 80b3 	bne.w	80013ae <mp45dt02ProcessingThd+0x58e>
        if (cmsisDsp.guard != MEMORY_GUARD)
 8001248:	4b72      	ldr	r3, [pc, #456]	; (8001414 <mp45dt02ProcessingThd+0x5f4>)
 800124a:	4a71      	ldr	r2, [pc, #452]	; (8001410 <mp45dt02ProcessingThd+0x5f0>)
 800124c:	681b      	ldr	r3, [r3, #0]
 800124e:	4293      	cmp	r3, r2
 8001250:	f040 80c0 	bne.w	80013d4 <mp45dt02ProcessingThd+0x5b4>
        if (output.guard != MEMORY_GUARD)
 8001254:	4b70      	ldr	r3, [pc, #448]	; (8001418 <mp45dt02ProcessingThd+0x5f8>)
 8001256:	4a6e      	ldr	r2, [pc, #440]	; (8001410 <mp45dt02ProcessingThd+0x5f0>)
 8001258:	681b      	ldr	r3, [r3, #0]
 800125a:	4293      	cmp	r3, r2
 800125c:	f43f aded 	beq.w	8000e3a <mp45dt02ProcessingThd+0x1a>
            PRINT_ERROR("Overflow detected.",0);
 8001260:	4c6e      	ldr	r4, [pc, #440]	; (800141c <mp45dt02ProcessingThd+0x5fc>)
 8001262:	f44f 4580 	mov.w	r5, #16384	; 0x4000
 8001266:	8325      	strh	r5, [r4, #24]
 8001268:	f241 3088 	movw	r0, #5000	; 0x1388
 800126c:	f7ff fda8 	bl	8000dc0 <chThdSleep>
 8001270:	8365      	strh	r5, [r4, #26]
 8001272:	f241 3088 	movw	r0, #5000	; 0x1388
 8001276:	f7ff fda3 	bl	8000dc0 <chThdSleep>
 800127a:	8325      	strh	r5, [r4, #24]
  __ASM volatile ("cpsid i" : : : "memory");
 800127c:	b672      	cpsid	i
  ch.dbg.panic_msg = reason;
 800127e:	4a68      	ldr	r2, [pc, #416]	; (8001420 <mp45dt02ProcessingThd+0x600>)
 8001280:	4b68      	ldr	r3, [pc, #416]	; (8001424 <mp45dt02ProcessingThd+0x604>)
 8001282:	62d3      	str	r3, [r2, #44]	; 0x2c
  while (true) {
 8001284:	e7fe      	b.n	8001284 <mp45dt02ProcessingThd+0x464>
    pb = pCoeffs;
 8001286:	9c10      	ldr	r4, [sp, #64]	; 0x40
    while (tapCnt > 0U)
 8001288:	4635      	mov	r5, r6
 800128a:	e6f0      	b.n	800106e <mp45dt02ProcessingThd+0x24e>
    pb = pCoeffs;
 800128c:	9a10      	ldr	r2, [sp, #64]	; 0x40
    while (tapCnt > 0U)
 800128e:	46a3      	mov	fp, r4
 8001290:	e780      	b.n	8001194 <mp45dt02ProcessingThd+0x374>
    currp->u.wtsemp = sp;
 8001292:	4b63      	ldr	r3, [pc, #396]	; (8001420 <mp45dt02ProcessingThd+0x600>)
  tp->queue.prev             = tqp->prev;
 8001294:	4611      	mov	r1, r2
 8001296:	699b      	ldr	r3, [r3, #24]
 8001298:	6852      	ldr	r2, [r2, #4]
 800129a:	6259      	str	r1, [r3, #36]	; 0x24
 800129c:	e9c3 1200 	strd	r1, r2, [r3]
    chSchGoSleepS(CH_STATE_WTSEM);
 80012a0:	2005      	movs	r0, #5
  tp->queue.prev->queue.next = tp;
 80012a2:	6013      	str	r3, [r2, #0]
  tqp->prev                  = tp;
 80012a4:	604b      	str	r3, [r1, #4]
 80012a6:	f7ff fc5b 	bl	8000b60 <chSchGoSleepS>
 80012aa:	e5d0      	b.n	8000e4e <mp45dt02ProcessingThd+0x2e>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80012ac:	2320      	movs	r3, #32
 80012ae:	f383 8811 	msr	BASEPRI, r3
 * @notapi
 */
void i2s_lld_stop_exchange(I2SDriver *i2sp) {

  /* Stop TX DMA, if enabled.*/
  if (NULL != i2sp->dmatx) {
 80012b2:	4d5d      	ldr	r5, [pc, #372]	; (8001428 <mp45dt02ProcessingThd+0x608>)
 80012b4:	696b      	ldr	r3, [r5, #20]
 80012b6:	b1b3      	cbz	r3, 80012e6 <mp45dt02ProcessingThd+0x4c6>
    dmaStreamDisable(i2sp->dmatx);
 80012b8:	681a      	ldr	r2, [r3, #0]
 80012ba:	6811      	ldr	r1, [r2, #0]
 80012bc:	f021 011f 	bic.w	r1, r1, #31
 80012c0:	6011      	str	r1, [r2, #0]
 80012c2:	6811      	ldr	r1, [r2, #0]
 80012c4:	07ce      	lsls	r6, r1, #31
 80012c6:	d4fc      	bmi.n	80012c2 <mp45dt02ProcessingThd+0x4a2>
 80012c8:	7a58      	ldrb	r0, [r3, #9]
 80012ca:	6859      	ldr	r1, [r3, #4]

    /* From the RM: To switch off the I2S, by clearing I2SE, it is mandatory
       to wait for TXE = 1 and BSY = 0.*/
    while ((i2sp->spi->SR & (SPI_SR_TXE | SPI_SR_BSY)) != SPI_SR_TXE)
 80012cc:	68aa      	ldr	r2, [r5, #8]
    dmaStreamDisable(i2sp->dmatx);
 80012ce:	233d      	movs	r3, #61	; 0x3d
 80012d0:	4083      	lsls	r3, r0
 80012d2:	600b      	str	r3, [r1, #0]
    while ((i2sp->spi->SR & (SPI_SR_TXE | SPI_SR_BSY)) != SPI_SR_TXE)
 80012d4:	6893      	ldr	r3, [r2, #8]
 80012d6:	f003 0382 	and.w	r3, r3, #130	; 0x82
 80012da:	2b02      	cmp	r3, #2
 80012dc:	d1fa      	bne.n	80012d4 <mp45dt02ProcessingThd+0x4b4>
      ;

    /* Stop SPI/I2S peripheral.*/
    i2sp->spi->I2SCFGR &= ~SPI_I2SCFGR_I2SE;
 80012de:	69d3      	ldr	r3, [r2, #28]
 80012e0:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80012e4:	61d3      	str	r3, [r2, #28]
  }

  /* Stop RX DMA, if enabled then draining the RX DR.*/
  if (NULL != i2sp->dmarx) {
 80012e6:	692b      	ldr	r3, [r5, #16]
 80012e8:	b1db      	cbz	r3, 8001322 <mp45dt02ProcessingThd+0x502>
    dmaStreamDisable(i2sp->dmarx);
 80012ea:	681a      	ldr	r2, [r3, #0]
 80012ec:	6811      	ldr	r1, [r2, #0]
 80012ee:	f021 011f 	bic.w	r1, r1, #31
 80012f2:	6011      	str	r1, [r2, #0]
 80012f4:	6811      	ldr	r1, [r2, #0]
 80012f6:	07cc      	lsls	r4, r1, #31
 80012f8:	d4fc      	bmi.n	80012f4 <mp45dt02ProcessingThd+0x4d4>
 80012fa:	7a58      	ldrb	r0, [r3, #9]
 80012fc:	6859      	ldr	r1, [r3, #4]

    /* Waiting for some data to be present in RX DR.*/
    while ((i2sp->spi->SR & SPI_SR_RXNE) != SPI_SR_RXNE)
 80012fe:	68ab      	ldr	r3, [r5, #8]
    dmaStreamDisable(i2sp->dmarx);
 8001300:	223d      	movs	r2, #61	; 0x3d
 8001302:	4082      	lsls	r2, r0
 8001304:	600a      	str	r2, [r1, #0]
    while ((i2sp->spi->SR & SPI_SR_RXNE) != SPI_SR_RXNE)
 8001306:	689a      	ldr	r2, [r3, #8]
 8001308:	07d0      	lsls	r0, r2, #31
 800130a:	d5fc      	bpl.n	8001306 <mp45dt02ProcessingThd+0x4e6>
      ;

    /* Stop SPI/I2S peripheral.*/
    i2sp->spi->I2SCFGR &= ~SPI_I2SCFGR_I2SE;
 800130c:	69da      	ldr	r2, [r3, #28]
 800130e:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8001312:	61da      	str	r2, [r3, #28]

    /* Purging data in DR.*/
    while ((i2sp->spi->SR & SPI_SR_RXNE) != 0)
 8001314:	689a      	ldr	r2, [r3, #8]
 8001316:	07d1      	lsls	r1, r2, #31
 8001318:	d503      	bpl.n	8001322 <mp45dt02ProcessingThd+0x502>
      (void) i2sp->spi->DR;
 800131a:	68da      	ldr	r2, [r3, #12]
    while ((i2sp->spi->SR & SPI_SR_RXNE) != 0)
 800131c:	689a      	ldr	r2, [r3, #8]
 800131e:	07d2      	lsls	r2, r2, #31
 8001320:	d4fb      	bmi.n	800131a <mp45dt02ProcessingThd+0x4fa>
  osalSysLock();
  osalDbgAssert((i2sp->state == I2S_READY) ||
                (i2sp->state == I2S_ACTIVE) ||
                (i2sp->state == I2S_COMPLETE),
                "invalid state");
  i2sStopExchangeI(i2sp);
 8001322:	2302      	movs	r3, #2
 8001324:	702b      	strb	r3, [r5, #0]
 8001326:	2300      	movs	r3, #0
 8001328:	f383 8811 	msr	BASEPRI, r3
            LED_ORANGE_CLEAR(); /* Breakpoint */
 800132c:	4c3b      	ldr	r4, [pc, #236]	; (800141c <mp45dt02ProcessingThd+0x5fc>)
                chTMStartMeasurementX(&debugTimings.oneSecond);
 800132e:	4f3f      	ldr	r7, [pc, #252]	; (800142c <mp45dt02ProcessingThd+0x60c>)
                if (palReadPad(GPIOA, GPIOA_BUTTON))
 8001330:	4e3f      	ldr	r6, [pc, #252]	; (8001430 <mp45dt02ProcessingThd+0x610>)
            LED_ORANGE_CLEAR(); /* Breakpoint */
 8001332:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8001336:	8363      	strh	r3, [r4, #26]
                LED_BLUE_TOGGLE();
 8001338:	6963      	ldr	r3, [r4, #20]
 800133a:	f483 4300 	eor.w	r3, r3, #32768	; 0x8000
 800133e:	6163      	str	r3, [r4, #20]
                chTMStartMeasurementX(&debugTimings.oneSecond);
 8001340:	4638      	mov	r0, r7
 8001342:	f7ff f9dd 	bl	8000700 <chTMStartMeasurementX>
                chThdSleepMilliseconds(1000);
 8001346:	f242 7010 	movw	r0, #10000	; 0x2710
 800134a:	f7ff fd39 	bl	8000dc0 <chThdSleep>
                chTMStopMeasurementX(&debugTimings.oneSecond);
 800134e:	4638      	mov	r0, r7
 8001350:	f7ff f9ae 	bl	80006b0 <chTMStopMeasurementX>
                if (palReadPad(GPIOA, GPIOA_BUTTON))
 8001354:	6933      	ldr	r3, [r6, #16]
 8001356:	07db      	lsls	r3, r3, #31
 8001358:	d5ee      	bpl.n	8001338 <mp45dt02ProcessingThd+0x518>
                    chThdSleepMilliseconds(10);
 800135a:	2064      	movs	r0, #100	; 0x64
 800135c:	f7ff fd30 	bl	8000dc0 <chThdSleep>
                    while (palReadPad(GPIOA, GPIOA_BUTTON));
 8001360:	4a33      	ldr	r2, [pc, #204]	; (8001430 <mp45dt02ProcessingThd+0x610>)
 8001362:	6914      	ldr	r4, [r2, #16]
 8001364:	f014 0401 	ands.w	r4, r4, #1
 8001368:	d1fb      	bne.n	8001362 <mp45dt02ProcessingThd+0x542>
                    LED_BLUE_CLEAR();
 800136a:	4e2c      	ldr	r6, [pc, #176]	; (800141c <mp45dt02ProcessingThd+0x5fc>)
                    chThdSleepMilliseconds(200);
 800136c:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 8001370:	f7ff fd26 	bl	8000dc0 <chThdSleep>
                    LED_BLUE_CLEAR();
 8001374:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8001378:	8373      	strh	r3, [r6, #26]
                    memset(output.buffer, 0, sizeof(output.buffer));
 800137a:	f44f 32c8 	mov.w	r2, #102400	; 0x19000
 800137e:	4621      	mov	r1, r4
 8001380:	482c      	ldr	r0, [pc, #176]	; (8001434 <mp45dt02ProcessingThd+0x614>)
 8001382:	f001 f83f 	bl	8002404 <memset>
                    output.count = 0;
 8001386:	4b20      	ldr	r3, [pc, #128]	; (8001408 <mp45dt02ProcessingThd+0x5e8>)
 8001388:	601c      	str	r4, [r3, #0]
 800138a:	2320      	movs	r3, #32
 800138c:	f383 8811 	msr	BASEPRI, r3
  i2sStartExchangeI(i2sp);
 8001390:	f7ff f89e 	bl	80004d0 <i2s_lld_start_exchange.constprop.0>
 8001394:	2303      	movs	r3, #3
 8001396:	702b      	strb	r3, [r5, #0]
 8001398:	f384 8811 	msr	BASEPRI, r4
                    LED_ORANGE_SET();
 800139c:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80013a0:	8333      	strh	r3, [r6, #24]
        if (mp45dt02I2sData.guard != MEMORY_GUARD)
 80013a2:	f8d8 3108 	ldr.w	r3, [r8, #264]	; 0x108
 80013a6:	4a1a      	ldr	r2, [pc, #104]	; (8001410 <mp45dt02ProcessingThd+0x5f0>)
 80013a8:	4293      	cmp	r3, r2
 80013aa:	f43f af4d 	beq.w	8001248 <mp45dt02ProcessingThd+0x428>
            PRINT_ERROR("Overflow detected.",0);
 80013ae:	4c1b      	ldr	r4, [pc, #108]	; (800141c <mp45dt02ProcessingThd+0x5fc>)
 80013b0:	f44f 4580 	mov.w	r5, #16384	; 0x4000
 80013b4:	8325      	strh	r5, [r4, #24]
 80013b6:	f241 3088 	movw	r0, #5000	; 0x1388
 80013ba:	f7ff fd01 	bl	8000dc0 <chThdSleep>
 80013be:	8365      	strh	r5, [r4, #26]
 80013c0:	f241 3088 	movw	r0, #5000	; 0x1388
 80013c4:	f7ff fcfc 	bl	8000dc0 <chThdSleep>
 80013c8:	8325      	strh	r5, [r4, #24]
  __ASM volatile ("cpsid i" : : : "memory");
 80013ca:	b672      	cpsid	i
  ch.dbg.panic_msg = reason;
 80013cc:	4a14      	ldr	r2, [pc, #80]	; (8001420 <mp45dt02ProcessingThd+0x600>)
 80013ce:	4b15      	ldr	r3, [pc, #84]	; (8001424 <mp45dt02ProcessingThd+0x604>)
 80013d0:	62d3      	str	r3, [r2, #44]	; 0x2c
  while (true) {
 80013d2:	e7fe      	b.n	80013d2 <mp45dt02ProcessingThd+0x5b2>
            PRINT_ERROR("Overflow detected.",0);
 80013d4:	4c11      	ldr	r4, [pc, #68]	; (800141c <mp45dt02ProcessingThd+0x5fc>)
 80013d6:	f44f 4580 	mov.w	r5, #16384	; 0x4000
 80013da:	8325      	strh	r5, [r4, #24]
 80013dc:	f241 3088 	movw	r0, #5000	; 0x1388
 80013e0:	f7ff fcee 	bl	8000dc0 <chThdSleep>
 80013e4:	8365      	strh	r5, [r4, #26]
 80013e6:	f241 3088 	movw	r0, #5000	; 0x1388
 80013ea:	f7ff fce9 	bl	8000dc0 <chThdSleep>
 80013ee:	8325      	strh	r5, [r4, #24]
 80013f0:	b672      	cpsid	i
  ch.dbg.panic_msg = reason;
 80013f2:	4a0b      	ldr	r2, [pc, #44]	; (8001420 <mp45dt02ProcessingThd+0x600>)
 80013f4:	4b0b      	ldr	r3, [pc, #44]	; (8001424 <mp45dt02ProcessingThd+0x604>)
 80013f6:	62d3      	str	r3, [r2, #44]	; 0x2c
  while (true) {
 80013f8:	e7fe      	b.n	80013f8 <mp45dt02ProcessingThd+0x5d8>
}
 80013fa:	b019      	add	sp, #100	; 0x64
 80013fc:	ecbd 8b0a 	vpop	{d8-d12}
 8001400:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001404:	20002350 	.word	0x20002350
 8001408:	200037e8 	.word	0x200037e8
 800140c:	20002398 	.word	0x20002398
 8001410:	deadbeef 	.word	0xdeadbeef
 8001414:	20002348 	.word	0x20002348
 8001418:	2001c7ec 	.word	0x2001c7ec
 800141c:	40020c00 	.word	0x40020c00
 8001420:	20000d18 	.word	0x20000d18
 8001424:	080024d8 	.word	0x080024d8
 8001428:	20000c00 	.word	0x20000c00
 800142c:	200023b0 	.word	0x200023b0
 8001430:	40020000 	.word	0x40020000
 8001434:	200037ec 	.word	0x200037ec
	...

08001440 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
 8001440:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001444:	ed2d 8b02 	vpush	{d8}
 8001448:	b083      	sub	sp, #12
 800144a:	ee08 3a10 	vmov	s16, r3
  qnotify_t nfy = oqp->q_notify;
 800144e:	69c7      	ldr	r7, [r0, #28]
                      size_t n, sysinterval_t timeout) {
 8001450:	9201      	str	r2, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8001452:	f04f 0920 	mov.w	r9, #32
 8001456:	f389 8811 	msr	BASEPRI, r9

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (n > 0U) {
 800145a:	b3a2      	cbz	r2, 80014c6 <oqWriteTimeout+0x86>
 800145c:	f8dd b004 	ldr.w	fp, [sp, #4]
 8001460:	4604      	mov	r4, r0
 8001462:	460e      	mov	r6, r1
 8001464:	f04f 0a00 	mov.w	sl, #0
  if (n > oqGetEmptyI(oqp)) {
 8001468:	68a2      	ldr	r2, [r4, #8]
 800146a:	4593      	cmp	fp, r2
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 800146c:	e9d4 2004 	ldrd	r2, r0, [r4, #16]
    n = oqGetEmptyI(oqp);
 8001470:	bf8c      	ite	hi
 8001472:	68a5      	ldrhi	r5, [r4, #8]
  if (n > oqGetEmptyI(oqp)) {
 8001474:	465d      	movls	r5, fp
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 8001476:	eba2 0800 	sub.w	r8, r2, r0
  if (n < s1) {
 800147a:	45a8      	cmp	r8, r5
 800147c:	d842      	bhi.n	8001504 <oqWriteTimeout+0xc4>
  else if (n > s1) {
 800147e:	d22b      	bcs.n	80014d8 <oqWriteTimeout+0x98>
    s2 = n - s1;
 8001480:	eba5 0308 	sub.w	r3, r5, r8
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
 8001484:	4642      	mov	r2, r8
 8001486:	4631      	mov	r1, r6
    s2 = n - s1;
 8001488:	9300      	str	r3, [sp, #0]
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
 800148a:	f7fe ff57 	bl	800033c <memcpy>
    memcpy((void *)oqp->q_buffer, (const void *)bp, s2);
 800148e:	eb06 0108 	add.w	r1, r6, r8
 8001492:	f8dd 8000 	ldr.w	r8, [sp]
 8001496:	68e0      	ldr	r0, [r4, #12]
 8001498:	4642      	mov	r2, r8
 800149a:	f7fe ff4f 	bl	800033c <memcpy>
  oqp->q_counter -= n;
 800149e:	68a2      	ldr	r2, [r4, #8]
    oqp->q_wrptr = oqp->q_buffer + s2;
 80014a0:	68e1      	ldr	r1, [r4, #12]
 80014a2:	4643      	mov	r3, r8
 80014a4:	18cb      	adds	r3, r1, r3
  oqp->q_counter -= n;
 80014a6:	1b52      	subs	r2, r2, r5
    oqp->q_wrptr = oqp->q_buffer + s2;
 80014a8:	6163      	str	r3, [r4, #20]
  oqp->q_counter -= n;
 80014aa:	60a2      	str	r2, [r4, #8]
      }
    }
    else {
      /* Inform the low side that the queue has at least one character
         available.*/
      if (nfy != NULL) {
 80014ac:	b10f      	cbz	r7, 80014b2 <oqWriteTimeout+0x72>
        nfy(oqp);
 80014ae:	4620      	mov	r0, r4
 80014b0:	47b8      	blx	r7
 80014b2:	f38a 8811 	msr	BASEPRI, sl
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();

      n  -= done;
 80014b6:	ebab 0b05 	sub.w	fp, fp, r5
      bp += done;
 80014ba:	442e      	add	r6, r5
 80014bc:	f389 8811 	msr	BASEPRI, r9
  while (n > 0U) {
 80014c0:	f1bb 0f00 	cmp.w	fp, #0
 80014c4:	d1d0      	bne.n	8001468 <oqWriteTimeout+0x28>
  if (n > oqGetEmptyI(oqp)) {
 80014c6:	9801      	ldr	r0, [sp, #4]
 80014c8:	2300      	movs	r3, #0
 80014ca:	f383 8811 	msr	BASEPRI, r3
    }
  }

  osalSysUnlock();
  return max - n;
}
 80014ce:	b003      	add	sp, #12
 80014d0:	ecbd 8b02 	vpop	{d8}
 80014d4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 80014d8:	462a      	mov	r2, r5
 80014da:	4631      	mov	r1, r6
 80014dc:	f7fe ff2e 	bl	800033c <memcpy>
    oqp->q_wrptr = oqp->q_buffer;
 80014e0:	68e2      	ldr	r2, [r4, #12]
 80014e2:	6162      	str	r2, [r4, #20]
  oqp->q_counter -= n;
 80014e4:	68a2      	ldr	r2, [r4, #8]
 80014e6:	1b52      	subs	r2, r2, r5
 80014e8:	60a2      	str	r2, [r4, #8]
    if (done == (size_t)0) {
 80014ea:	2d00      	cmp	r5, #0
 80014ec:	d1de      	bne.n	80014ac <oqWriteTimeout+0x6c>
 80014ee:	ee18 1a10 	vmov	r1, s16
 80014f2:	4620      	mov	r0, r4
 80014f4:	f7ff fbd4 	bl	8000ca0 <chThdEnqueueTimeoutS>
      if (msg != MSG_OK) {
 80014f8:	2800      	cmp	r0, #0
 80014fa:	d0b5      	beq.n	8001468 <oqWriteTimeout+0x28>
 80014fc:	9b01      	ldr	r3, [sp, #4]
 80014fe:	eba3 000b 	sub.w	r0, r3, fp
 8001502:	e7e1      	b.n	80014c8 <oqWriteTimeout+0x88>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 8001504:	462a      	mov	r2, r5
 8001506:	4631      	mov	r1, r6
 8001508:	f7fe ff18 	bl	800033c <memcpy>
    oqp->q_wrptr += n;
 800150c:	6962      	ldr	r2, [r4, #20]
 800150e:	442a      	add	r2, r5
 8001510:	6162      	str	r2, [r4, #20]
 8001512:	e7e7      	b.n	80014e4 <oqWriteTimeout+0xa4>
	...

08001520 <_writet>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8001520:	3030      	adds	r0, #48	; 0x30
 8001522:	f7ff bf8d 	b.w	8001440 <oqWriteTimeout>
 8001526:	bf00      	nop
	...

08001530 <_write>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8001530:	3030      	adds	r0, #48	; 0x30
 8001532:	f04f 33ff 	mov.w	r3, #4294967295
 8001536:	f7ff bf83 	b.w	8001440 <oqWriteTimeout>
 800153a:	bf00      	nop
 800153c:	0000      	movs	r0, r0
	...

08001540 <iqReadTimeout>:
                     size_t n, sysinterval_t timeout) {
 8001540:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001544:	ed2d 8b02 	vpush	{d8}
 8001548:	b083      	sub	sp, #12
 800154a:	ee08 3a10 	vmov	s16, r3
  qnotify_t nfy = iqp->q_notify;
 800154e:	69c7      	ldr	r7, [r0, #28]
                     size_t n, sysinterval_t timeout) {
 8001550:	9201      	str	r2, [sp, #4]
 8001552:	f04f 0920 	mov.w	r9, #32
 8001556:	f389 8811 	msr	BASEPRI, r9
  while (n > 0U) {
 800155a:	2a00      	cmp	r2, #0
 800155c:	d034      	beq.n	80015c8 <iqReadTimeout+0x88>
 800155e:	f8dd b004 	ldr.w	fp, [sp, #4]
 8001562:	4604      	mov	r4, r0
 8001564:	460e      	mov	r6, r1
 8001566:	f04f 0a00 	mov.w	sl, #0
  if (n > iqGetFullI(iqp)) {
 800156a:	68a2      	ldr	r2, [r4, #8]
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 800156c:	69a1      	ldr	r1, [r4, #24]
  if (n > iqGetFullI(iqp)) {
 800156e:	4593      	cmp	fp, r2
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 8001570:	6922      	ldr	r2, [r4, #16]
    n = iqGetFullI(iqp);
 8001572:	bf8c      	ite	hi
 8001574:	68a5      	ldrhi	r5, [r4, #8]
  if (n > iqGetFullI(iqp)) {
 8001576:	465d      	movls	r5, fp
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 8001578:	eba2 0801 	sub.w	r8, r2, r1
  if (n < s1) {
 800157c:	45a8      	cmp	r8, r5
 800157e:	d842      	bhi.n	8001606 <iqReadTimeout+0xc6>
  else if (n > s1) {
 8001580:	d22b      	bcs.n	80015da <iqReadTimeout+0x9a>
    s2 = n - s1;
 8001582:	eba5 0308 	sub.w	r3, r5, r8
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
 8001586:	4642      	mov	r2, r8
 8001588:	4630      	mov	r0, r6
    s2 = n - s1;
 800158a:	9300      	str	r3, [sp, #0]
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
 800158c:	f7fe fed6 	bl	800033c <memcpy>
    memcpy((void *)bp, (void *)iqp->q_buffer, s2);
 8001590:	eb06 0008 	add.w	r0, r6, r8
 8001594:	f8dd 8000 	ldr.w	r8, [sp]
 8001598:	68e1      	ldr	r1, [r4, #12]
 800159a:	4642      	mov	r2, r8
 800159c:	f7fe fece 	bl	800033c <memcpy>
  iqp->q_counter -= n;
 80015a0:	68a2      	ldr	r2, [r4, #8]
    iqp->q_rdptr = iqp->q_buffer + s2;
 80015a2:	68e1      	ldr	r1, [r4, #12]
 80015a4:	4643      	mov	r3, r8
 80015a6:	18cb      	adds	r3, r1, r3
  iqp->q_counter -= n;
 80015a8:	1b52      	subs	r2, r2, r5
    iqp->q_rdptr = iqp->q_buffer + s2;
 80015aa:	61a3      	str	r3, [r4, #24]
  iqp->q_counter -= n;
 80015ac:	60a2      	str	r2, [r4, #8]
      if (nfy != NULL) {
 80015ae:	b10f      	cbz	r7, 80015b4 <iqReadTimeout+0x74>
        nfy(iqp);
 80015b0:	4620      	mov	r0, r4
 80015b2:	47b8      	blx	r7
 80015b4:	f38a 8811 	msr	BASEPRI, sl
      n  -= done;
 80015b8:	ebab 0b05 	sub.w	fp, fp, r5
      bp += done;
 80015bc:	442e      	add	r6, r5
 80015be:	f389 8811 	msr	BASEPRI, r9
  while (n > 0U) {
 80015c2:	f1bb 0f00 	cmp.w	fp, #0
 80015c6:	d1d0      	bne.n	800156a <iqReadTimeout+0x2a>
  if (n > iqGetFullI(iqp)) {
 80015c8:	9801      	ldr	r0, [sp, #4]
 80015ca:	2300      	movs	r3, #0
 80015cc:	f383 8811 	msr	BASEPRI, r3
}
 80015d0:	b003      	add	sp, #12
 80015d2:	ecbd 8b02 	vpop	{d8}
 80015d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 80015da:	462a      	mov	r2, r5
 80015dc:	4630      	mov	r0, r6
 80015de:	f7fe fead 	bl	800033c <memcpy>
    iqp->q_rdptr = iqp->q_buffer;
 80015e2:	68e2      	ldr	r2, [r4, #12]
 80015e4:	61a2      	str	r2, [r4, #24]
  iqp->q_counter -= n;
 80015e6:	68a2      	ldr	r2, [r4, #8]
 80015e8:	1b52      	subs	r2, r2, r5
 80015ea:	60a2      	str	r2, [r4, #8]
    if (done == (size_t)0) {
 80015ec:	2d00      	cmp	r5, #0
 80015ee:	d1de      	bne.n	80015ae <iqReadTimeout+0x6e>
 80015f0:	ee18 1a10 	vmov	r1, s16
 80015f4:	4620      	mov	r0, r4
 80015f6:	f7ff fb53 	bl	8000ca0 <chThdEnqueueTimeoutS>
      if (msg != MSG_OK) {
 80015fa:	2800      	cmp	r0, #0
 80015fc:	d0b5      	beq.n	800156a <iqReadTimeout+0x2a>
 80015fe:	9b01      	ldr	r3, [sp, #4]
 8001600:	eba3 000b 	sub.w	r0, r3, fp
 8001604:	e7e1      	b.n	80015ca <iqReadTimeout+0x8a>
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 8001606:	462a      	mov	r2, r5
 8001608:	4630      	mov	r0, r6
 800160a:	f7fe fe97 	bl	800033c <memcpy>
    iqp->q_rdptr += n;
 800160e:	69a2      	ldr	r2, [r4, #24]
 8001610:	442a      	add	r2, r5
 8001612:	61a2      	str	r2, [r4, #24]
 8001614:	e7e7      	b.n	80015e6 <iqReadTimeout+0xa6>
 8001616:	bf00      	nop
	...

08001620 <_readt>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8001620:	300c      	adds	r0, #12
 8001622:	f7ff bf8d 	b.w	8001540 <iqReadTimeout>
 8001626:	bf00      	nop
	...

08001630 <_read>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8001630:	300c      	adds	r0, #12
 8001632:	f04f 33ff 	mov.w	r3, #4294967295
 8001636:	f7ff bf83 	b.w	8001540 <iqReadTimeout>
 800163a:	bf00      	nop
 800163c:	0000      	movs	r0, r0
	...

08001640 <main>:

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).
     Note, GPIOs are not reset because initialized before this point in
     board files.*/
  rccResetAHB1(~STM32_GPIO_EN_MASK);
 8001640:	4b26      	ldr	r3, [pc, #152]	; (80016dc <main+0x9c>)
  PWR->CR |= PWR_CR_DBP;
 8001642:	4827      	ldr	r0, [pc, #156]	; (80016e0 <main+0xa0>)
  rccResetAHB1(~STM32_GPIO_EN_MASK);
 8001644:	691a      	ldr	r2, [r3, #16]
 8001646:	ea6f 52c2 	mvn.w	r2, r2, lsl #23
 800164a:	ea6f 52d2 	mvn.w	r2, r2, lsr #23
 * Application entry point.
 */



int main(void) {
 800164e:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 8001652:	611a      	str	r2, [r3, #16]
 8001654:	691a      	ldr	r2, [r3, #16]
 8001656:	f3c2 0208 	ubfx	r2, r2, #0, #9
 800165a:	611a      	str	r2, [r3, #16]
#if !defined(STM32F410xx)
  rccResetAHB2(~0);
 800165c:	f04f 34ff 	mov.w	r4, #4294967295
  rccResetAHB1(~STM32_GPIO_EN_MASK);
 8001660:	691a      	ldr	r2, [r3, #16]
  rccResetAHB2(~0);
 8001662:	695a      	ldr	r2, [r3, #20]
 8001664:	615c      	str	r4, [r3, #20]
 8001666:	2200      	movs	r2, #0
 8001668:	6959      	ldr	r1, [r3, #20]
 800166a:	615a      	str	r2, [r3, #20]
 800166c:	6959      	ldr	r1, [r3, #20]
#endif
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 800166e:	6a19      	ldr	r1, [r3, #32]
 8001670:	f061 5180 	orn	r1, r1, #268435456	; 0x10000000
 8001674:	6219      	str	r1, [r3, #32]
 8001676:	6a19      	ldr	r1, [r3, #32]
 8001678:	f001 5180 	and.w	r1, r1, #268435456	; 0x10000000
 800167c:	6219      	str	r1, [r3, #32]
 800167e:	6a19      	ldr	r1, [r3, #32]
  rccResetAPB2(~0);
 8001680:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8001682:	625c      	str	r4, [r3, #36]	; 0x24
 8001684:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8001686:	625a      	str	r2, [r3, #36]	; 0x24
 8001688:	6a59      	ldr	r1, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(true);
 800168a:	6c19      	ldr	r1, [r3, #64]	; 0x40
 800168c:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8001690:	6419      	str	r1, [r3, #64]	; 0x40
 8001692:	6e19      	ldr	r1, [r3, #96]	; 0x60
 8001694:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8001698:	6619      	str	r1, [r3, #96]	; 0x60
 800169a:	6e19      	ldr	r1, [r3, #96]	; 0x60
  PWR->CR |= PWR_CR_DBP;
 800169c:	6801      	ldr	r1, [r0, #0]
 800169e:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 80016a2:	6001      	str	r1, [r0, #0]
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 80016a4:	6f19      	ldr	r1, [r3, #112]	; 0x70
 80016a6:	f401 7140 	and.w	r1, r1, #768	; 0x300
 80016aa:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 80016ae:	b087      	sub	sp, #28
 80016b0:	d003      	beq.n	80016ba <main+0x7a>
    RCC->BDCR = RCC_BDCR_BDRST;
 80016b2:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 80016b6:	6719      	str	r1, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 80016b8:	671a      	str	r2, [r3, #112]	; 0x70
  PWR->CSR &= ~PWR_CSR_BRE;
 80016ba:	4c09      	ldr	r4, [pc, #36]	; (80016e0 <main+0xa0>)
 * @init
 */
void dmaInit(void) {
  unsigned i;

  dma.allocated_mask = 0U;
 80016bc:	4909      	ldr	r1, [pc, #36]	; (80016e4 <main+0xa4>)
 80016be:	6862      	ldr	r2, [r4, #4]
 80016c0:	4b09      	ldr	r3, [pc, #36]	; (80016e8 <main+0xa8>)
 80016c2:	4d0a      	ldr	r5, [pc, #40]	; (80016ec <main+0xac>)
 80016c4:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 80016c8:	2000      	movs	r0, #0
 80016ca:	6062      	str	r2, [r4, #4]
 80016cc:	4688      	mov	r8, r1
 80016ce:	6008      	str	r0, [r1, #0]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 80016d0:	460a      	mov	r2, r1
    _stm32_dma_streams[i].stream->CR = STM32_DMA_CR_RESET_VALUE;
 80016d2:	4607      	mov	r7, r0
 80016d4:	f103 01c0 	add.w	r1, r3, #192	; 0xc0
 80016d8:	e00c      	b.n	80016f4 <main+0xb4>
 80016da:	bf00      	nop
 80016dc:	40023800 	.word	0x40023800
 80016e0:	40007000 	.word	0x40007000
 80016e4:	200023e4 	.word	0x200023e4
 80016e8:	080024f4 	.word	0x080024f4
 80016ec:	40026010 	.word	0x40026010
 80016f0:	f853 5c0c 	ldr.w	r5, [r3, #-12]
 80016f4:	602f      	str	r7, [r5, #0]
    dma.streams[i].func = NULL;
 80016f6:	330c      	adds	r3, #12
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 80016f8:	428b      	cmp	r3, r1
    dma.streams[i].func = NULL;
 80016fa:	6057      	str	r7, [r2, #4]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 80016fc:	f102 0208 	add.w	r2, r2, #8
 8001700:	d1f6      	bne.n	80016f0 <main+0xb0>

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001702:	4cc7      	ldr	r4, [pc, #796]	; (8001a20 <main+0x3e0>)
  i2sp->state  = I2S_STOP;
 8001704:	4dc7      	ldr	r5, [pc, #796]	; (8001a24 <main+0x3e4>)
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
 8001706:	4ec8      	ldr	r6, [pc, #800]	; (8001a28 <main+0x3e8>)
  DMA1->HIFCR = 0xFFFFFFFFU;
  DMA2->LIFCR = 0xFFFFFFFFU;
 8001708:	4ac8      	ldr	r2, [pc, #800]	; (8001a2c <main+0x3ec>)
  i2sp->config = NULL;
 800170a:	606f      	str	r7, [r5, #4]
 800170c:	2360      	movs	r3, #96	; 0x60
  DMA1->LIFCR = 0xFFFFFFFFU;
 800170e:	f04f 39ff 	mov.w	r9, #4294967295
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001712:	2140      	movs	r1, #64	; 0x40
 8001714:	f8c6 9008 	str.w	r9, [r6, #8]
 8001718:	f04f 0b80 	mov.w	fp, #128	; 0x80
  I2SD2.dmarx     = NULL;
 800171c:	612f      	str	r7, [r5, #16]
  DMA1->HIFCR = 0xFFFFFFFFU;
 800171e:	f8c6 900c 	str.w	r9, [r6, #12]
  DMA2->LIFCR = 0xFFFFFFFFU;
 8001722:	f8c2 9008 	str.w	r9, [r2, #8]
  I2SD2.dmatx     = NULL;
 8001726:	616f      	str	r7, [r5, #20]
  DMA2->HIFCR = 0xFFFFFFFFU;
 8001728:	f8c2 900c 	str.w	r9, [r2, #12]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800172c:	f884 3306 	strb.w	r3, [r4, #774]	; 0x306
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001730:	f44f 7280 	mov.w	r2, #256	; 0x100
 8001734:	f8c4 1180 	str.w	r1, [r4, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001738:	6021      	str	r1, [r4, #0]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800173a:	f44f 7100 	mov.w	r1, #512	; 0x200
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800173e:	f884 3307 	strb.w	r3, [r4, #775]	; 0x307
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001742:	f8c4 b180 	str.w	fp, [r4, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001746:	f8c4 b000 	str.w	fp, [r4]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800174a:	f884 3308 	strb.w	r3, [r4, #776]	; 0x308
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800174e:	f8c4 2180 	str.w	r2, [r4, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001752:	6022      	str	r2, [r4, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001754:	f884 3309 	strb.w	r3, [r4, #777]	; 0x309
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001758:	f8c4 1180 	str.w	r1, [r4, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800175c:	6021      	str	r1, [r4, #0]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800175e:	f44f 6180 	mov.w	r1, #1024	; 0x400
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001762:	f884 330a 	strb.w	r3, [r4, #778]	; 0x30a
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001766:	f8c4 1180 	str.w	r1, [r4, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800176a:	6021      	str	r1, [r4, #0]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800176c:	f44f 0100 	mov.w	r1, #8388608	; 0x800000
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001770:	f884 3317 	strb.w	r3, [r4, #791]	; 0x317
  I2SD2.spi       = SPI2;
 8001774:	f5a6 360a 	sub.w	r6, r6, #141312	; 0x22800
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001778:	f8c4 1180 	str.w	r1, [r4, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800177c:	6021      	str	r1, [r4, #0]
  I2SD2.cfg       = STM32_I2S2_CFGR_CFG;
 800177e:	f44f 7140 	mov.w	r1, #768	; 0x300
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001782:	f884 3328 	strb.w	r3, [r4, #808]	; 0x328
 * @notapi
 */
void sd_lld_init(void) {

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
 8001786:	48aa      	ldr	r0, [pc, #680]	; (8001a30 <main+0x3f0>)
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001788:	f8c4 2184 	str.w	r2, [r4, #388]	; 0x184
  I2SD2.rxdmamode = STM32_DMA_CR_CHSEL(I2S2_RX_DMA_CHANNEL) |
 800178c:	4ba9      	ldr	r3, [pc, #676]	; (8001a34 <main+0x3f4>)
  I2SD2.spi       = SPI2;
 800178e:	60ae      	str	r6, [r5, #8]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001790:	6062      	str	r2, [r4, #4]
  i2sp->state  = I2S_STOP;
 8001792:	2201      	movs	r2, #1
  I2SD2.cfg       = STM32_I2S2_CFGR_CFG;
 8001794:	81a9      	strh	r1, [r5, #12]
 8001796:	49a8      	ldr	r1, [pc, #672]	; (8001a38 <main+0x3f8>)
 8001798:	702a      	strb	r2, [r5, #0]
  I2SD2.rxdmamode = STM32_DMA_CR_CHSEL(I2S2_RX_DMA_CHANNEL) |
 800179a:	61ab      	str	r3, [r5, #24]
  I2SD2.txdmamode = 0;
 800179c:	61ef      	str	r7, [r5, #28]
 800179e:	f7fe fe67 	bl	8000470 <sdObjectInit.constprop.0>
  SD1.usart = USART1;
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
 80017a2:	f8df a300 	ldr.w	sl, [pc, #768]	; 8001aa4 <main+0x464>
  SD1.usart = USART1;
 80017a6:	4ba5      	ldr	r3, [pc, #660]	; (8001a3c <main+0x3fc>)
 80017a8:	6743      	str	r3, [r0, #116]	; 0x74
  sdObjectInit(&SD2, NULL, notify2);
 80017aa:	49a5      	ldr	r1, [pc, #660]	; (8001a40 <main+0x400>)
  tqp->next = (thread_t *)tqp;
 80017ac:	4ea5      	ldr	r6, [pc, #660]	; (8001a44 <main+0x404>)
 80017ae:	4650      	mov	r0, sl
 80017b0:	f7fe fe5e 	bl	8000470 <sdObjectInit.constprop.0>

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 80017b4:	4ba4      	ldr	r3, [pc, #656]	; (8001a48 <main+0x408>)

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 80017b6:	48a5      	ldr	r0, [pc, #660]	; (8001a4c <main+0x40c>)
  ST_ENABLE_CLOCK();
 80017b8:	6c19      	ldr	r1, [r3, #64]	; 0x40
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAlignedWithOffset;
 80017ba:	f8df c2ec 	ldr.w	ip, [pc, #748]	; 8001aa8 <main+0x468>
  ch_memcore.basemem = __heap_base__;
 80017be:	f8df e2ec 	ldr.w	lr, [pc, #748]	; 8001aac <main+0x46c>
 80017c2:	f041 0101 	orr.w	r1, r1, #1
 80017c6:	6419      	str	r1, [r3, #64]	; 0x40
 80017c8:	6e19      	ldr	r1, [r3, #96]	; 0x60
 80017ca:	f041 0101 	orr.w	r1, r1, #1
 80017ce:	6619      	str	r1, [r3, #96]	; 0x60
 80017d0:	6e1b      	ldr	r3, [r3, #96]	; 0x60
  ST_ENABLE_STOP();
 80017d2:	6883      	ldr	r3, [r0, #8]
  tqp->prev = (thread_t *)tqp;
 80017d4:	6076      	str	r6, [r6, #4]
 80017d6:	f043 0301 	orr.w	r3, r3, #1
 80017da:	6083      	str	r3, [r0, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80017dc:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
#if ST_LLD_NUM_ALARMS > 3
  STM32_ST_TIM->CCR[3] = 0;
#endif
  STM32_ST_TIM->DIER   = 0;
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 80017e0:	2201      	movs	r2, #1
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80017e2:	f242 00cf 	movw	r0, #8399	; 0x20cf
 80017e6:	6298      	str	r0, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 80017e8:	f8c3 902c 	str.w	r9, [r3, #44]	; 0x2c
  ch.rlist.prio = NOPRIO;
 80017ec:	60b7      	str	r7, [r6, #8]
  STM32_ST_TIM->CCMR1  = 0;
 80017ee:	619f      	str	r7, [r3, #24]
  ch.rlist.newer = (thread_t *)&ch.rlist;
 80017f0:	6136      	str	r6, [r6, #16]
  STM32_ST_TIM->CCR[0] = 0;
 80017f2:	635f      	str	r7, [r3, #52]	; 0x34
  ch.rlist.older = (thread_t *)&ch.rlist;
 80017f4:	6176      	str	r6, [r6, #20]
  STM32_ST_TIM->DIER   = 0;
 80017f6:	60df      	str	r7, [r3, #12]
  ch.vtlist.delta = (sysinterval_t)-1;
 80017f8:	f8c6 9024 	str.w	r9, [r6, #36]	; 0x24
  STM32_ST_TIM->CR2    = 0;
 80017fc:	605f      	str	r7, [r3, #4]
  ch.vtlist.lasttime = (systime_t)0;
 80017fe:	62b7      	str	r7, [r6, #40]	; 0x28
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8001800:	615a      	str	r2, [r3, #20]
  H_NEXT(&default_heap.header) = NULL;
 8001802:	f8cc 7004 	str.w	r7, [ip, #4]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8001806:	601a      	str	r2, [r3, #0]
  SD2.usart = USART2;
 8001808:	f503 4388 	add.w	r3, r3, #17408	; 0x4400
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800180c:	f884 b31c 	strb.w	fp, [r4, #796]	; 0x31c
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001810:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8001814:	f8ca 3074 	str.w	r3, [sl, #116]	; 0x74
 8001818:	498d      	ldr	r1, [pc, #564]	; (8001a50 <main+0x410>)
  ch_memcore.topmem  = __heap_end__;
 800181a:	488e      	ldr	r0, [pc, #568]	; (8001a54 <main+0x414>)
 800181c:	f8c4 2180 	str.w	r2, [r4, #384]	; 0x180
  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8001820:	f106 031c 	add.w	r3, r6, #28
 8001824:	61f3      	str	r3, [r6, #28]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001826:	6022      	str	r2, [r4, #0]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 8001828:	6233      	str	r3, [r6, #32]
  tqp->next = (thread_t *)tqp;
 800182a:	4b8b      	ldr	r3, [pc, #556]	; (8001a58 <main+0x418>)
  default_heap.provider = chCoreAllocAlignedWithOffset;
 800182c:	4a8b      	ldr	r2, [pc, #556]	; (8001a5c <main+0x41c>)
 800182e:	f8cc 2000 	str.w	r2, [ip]
 8001832:	e9c1 e000 	strd	lr, r0, [r1]
  tmp->cumulative = (rttime_t)0;
 8001836:	2000      	movs	r0, #0
 8001838:	2100      	movs	r1, #0
 800183a:	6036      	str	r6, [r6, #0]
  H_PAGES(&default_heap.header) = 0;
 800183c:	f8cc 7008 	str.w	r7, [ip, #8]
 8001840:	e9cd 0104 	strd	r0, r1, [sp, #16]
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  mp->owner = NULL;
 8001844:	f8cc 7014 	str.w	r7, [ip, #20]
  tmp->last       = (rtcnt_t)0;
 8001848:	e9cd 7701 	strd	r7, r7, [sp, #4]
  ch.tm.offset = (rtcnt_t)0;
 800184c:	6777      	str	r7, [r6, #116]	; 0x74
  tmp->n          = (ucnt_t)0;
 800184e:	9703      	str	r7, [sp, #12]
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void dyn_list_init(dyn_list_t *dlp) {

  dlp->next = (dyn_element_t *)dlp;
 8001850:	f103 003c 	add.w	r0, r3, #60	; 0x3c
 8001854:	609f      	str	r7, [r3, #8]
  chDbgCheck((mp != NULL) &&
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
 8001856:	615f      	str	r7, [r3, #20]
 8001858:	62df      	str	r7, [r3, #44]	; 0x2c
 800185a:	f103 0740 	add.w	r7, r3, #64	; 0x40
 800185e:	f10c 020c 	add.w	r2, ip, #12
 8001862:	f103 0110 	add.w	r1, r3, #16
  mp->object_size = size;
 8001866:	2414      	movs	r4, #20
  tqp->prev = (thread_t *)tqp;
 8001868:	e9c3 3300 	strd	r3, r3, [r3]
 800186c:	e9c3 070f 	strd	r0, r7, [r3, #60]	; 0x3c
 8001870:	e9cc 2203 	strd	r2, r2, [ip, #12]
 8001874:	f103 0a24 	add.w	sl, r3, #36	; 0x24
  mp->align = align;
  mp->provider = provider;
 8001878:	4a79      	ldr	r2, [pc, #484]	; (8001a60 <main+0x420>)
 800187a:	6119      	str	r1, [r3, #16]
 800187c:	f103 0e28 	add.w	lr, r3, #40	; 0x28
  mp->object_size = size;
 8001880:	f04f 0c1c 	mov.w	ip, #28
 8001884:	f103 0144 	add.w	r1, r3, #68	; 0x44
 8001888:	619c      	str	r4, [r3, #24]
  mp->align = align;
 800188a:	2404      	movs	r4, #4
  tmp->best       = (rtcnt_t)-1;
 800188c:	f8cd 9000 	str.w	r9, [sp]
 8001890:	f8c3 a024 	str.w	sl, [r3, #36]	; 0x24
 8001894:	f8c3 e028 	str.w	lr, [r3, #40]	; 0x28
  mp->object_size = size;
 8001898:	f8c3 c030 	str.w	ip, [r3, #48]	; 0x30
 800189c:	6459      	str	r1, [r3, #68]	; 0x44
  mp->align = align;
 800189e:	61dc      	str	r4, [r3, #28]
 80018a0:	635c      	str	r4, [r3, #52]	; 0x34
  mp->provider = provider;
 80018a2:	621a      	str	r2, [r3, #32]
 80018a4:	639a      	str	r2, [r3, #56]	; 0x38
    chTMStartMeasurementX(&tm);
 80018a6:	4668      	mov	r0, sp
 80018a8:	f7fe ff2a 	bl	8000700 <chTMStartMeasurementX>
    chTMStopMeasurementX(&tm);
 80018ac:	4668      	mov	r0, sp
 80018ae:	f7fe feff 	bl	80006b0 <chTMStopMeasurementX>
  } while (i > 0U);
 80018b2:	3c01      	subs	r4, #1
 80018b4:	d1f7      	bne.n	80018a6 <main+0x266>
  REG_INSERT(tp);
 80018b6:	4b6b      	ldr	r3, [pc, #428]	; (8001a64 <main+0x424>)
 80018b8:	6977      	ldr	r7, [r6, #20]
  tp->name      = name;
 80018ba:	f8df e1f4 	ldr.w	lr, [pc, #500]	; 8001ab0 <main+0x470>
  ch.tm.offset = tm.best;
 80018be:	9900      	ldr	r1, [sp, #0]
  tp->flags     = CH_FLAG_MODE_STATIC;
 80018c0:	f886 4051 	strb.w	r4, [r6, #81]	; 0x51
  tp->prio      = prio;
 80018c4:	f04f 0b80 	mov.w	fp, #128	; 0x80
  tp->refs      = (trefs_t)1;
 80018c8:	2201      	movs	r2, #1
  tqp->next = (thread_t *)tqp;
 80018ca:	f103 002c 	add.w	r0, r3, #44	; 0x2c
  tlp->next = (thread_t *)tlp;
 80018ce:	f103 0c28 	add.w	ip, r3, #40	; 0x28
  tp->epending  = (eventmask_t)0;
 80018d2:	e9c6 4419 	strd	r4, r4, [r6, #100]	; 0x64
  REG_INSERT(tp);
 80018d6:	e9c6 6710 	strd	r6, r7, [r6, #64]	; 0x40
 80018da:	6771      	str	r1, [r6, #116]	; 0x74
  tp->prio      = prio;
 80018dc:	f8c6 b038 	str.w	fp, [r6, #56]	; 0x38
  tp->realprio  = prio;
 80018e0:	f8c6 b06c 	str.w	fp, [r6, #108]	; 0x6c
  tp->refs      = (trefs_t)1;
 80018e4:	f886 2052 	strb.w	r2, [r6, #82]	; 0x52
  tp->name      = name;
 80018e8:	f8c6 e048 	str.w	lr, [r6, #72]	; 0x48
 80018ec:	f04f 0a20 	mov.w	sl, #32
  REG_INSERT(tp);
 80018f0:	613b      	str	r3, [r7, #16]
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 80018f2:	e9c6 3305 	strd	r3, r3, [r6, #20]
  tqp->next = (thread_t *)tqp;
 80018f6:	e9c6 c016 	strd	ip, r0, [r6, #88]	; 0x58
  currp->state = CH_STATE_CURRENT;
 80018fa:	f886 2050 	strb.w	r2, [r6, #80]	; 0x50
  currp->wabase = NULL;
 80018fe:	64f4      	str	r4, [r6, #76]	; 0x4c
  tqp->prev = (thread_t *)tqp;
 8001900:	6630      	str	r0, [r6, #96]	; 0x60
 8001902:	f38a 8811 	msr	BASEPRI, sl
  __ASM volatile ("cpsie i" : : : "memory");
 8001906:	b662      	cpsie	i
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8001908:	4b57      	ldr	r3, [pc, #348]	; (8001a68 <main+0x428>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 800190a:	4958      	ldr	r1, [pc, #352]	; (8001a6c <main+0x42c>)
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800190c:	68d8      	ldr	r0, [r3, #12]
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 800190e:	4f58      	ldr	r7, [pc, #352]	; (8001a70 <main+0x430>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8001910:	f64f 0cff 	movw	ip, #63743	; 0xf8ff
 8001914:	ea00 000c 	and.w	r0, r0, ip
  reg_value  =  (reg_value                                   |
 8001918:	4301      	orrs	r1, r0
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
  SCB->AIRCR =  reg_value;
 800191a:	60d9      	str	r1, [r3, #12]
 800191c:	68f9      	ldr	r1, [r7, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 800191e:	4855      	ldr	r0, [pc, #340]	; (8001a74 <main+0x434>)
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8001920:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
 8001924:	60f9      	str	r1, [r7, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8001926:	6801      	ldr	r1, [r0, #0]
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001928:	2710      	movs	r7, #16
 800192a:	4311      	orrs	r1, r2
 800192c:	6001      	str	r1, [r0, #0]
 800192e:	77df      	strb	r7, [r3, #31]
 8001930:	f883 a022 	strb.w	sl, [r3, #34]	; 0x22
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8001934:	f384 8811 	msr	BASEPRI, r4
  __ASM volatile ("cpsie i" : : : "memory");
 8001938:	b662      	cpsie	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800193a:	f38a 8811 	msr	BASEPRI, sl
  tp->wabase = tdp->wbase;
 800193e:	4b4e      	ldr	r3, [pc, #312]	; (8001a78 <main+0x438>)
  REG_INSERT(tp);
 8001940:	6971      	ldr	r1, [r6, #20]
  tp->prio      = prio;
 8001942:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
  tp->mtxlist   = NULL;
 8001946:	e9c3 4254 	strd	r4, r2, [r3, #336]	; 0x150
  tp->refs      = (trefs_t)1;
 800194a:	f883 213a 	strb.w	r2, [r3, #314]	; 0x13a
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 800194e:	484b      	ldr	r0, [pc, #300]	; (8001a7c <main+0x43c>)
 8001950:	f8c3 00f4 	str.w	r0, [r3, #244]	; 0xf4
 8001954:	f103 02b4 	add.w	r2, r3, #180	; 0xb4
 8001958:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
  REG_INSERT(tp);
 800195c:	f503 708c 	add.w	r0, r3, #280	; 0x118
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8001960:	f8df c150 	ldr.w	ip, [pc, #336]	; 8001ab4 <main+0x474>
  tp->name      = name;
 8001964:	4f46      	ldr	r7, [pc, #280]	; (8001a80 <main+0x440>)
  REG_INSERT(tp);
 8001966:	f8c3 112c 	str.w	r1, [r3, #300]	; 0x12c
  tp->state     = CH_STATE_WTSTART;
 800196a:	2202      	movs	r2, #2
 800196c:	f8a3 2138 	strh.w	r2, [r3, #312]	; 0x138
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8001970:	f8c3 40f8 	str.w	r4, [r3, #248]	; 0xf8
  tqp->next = (thread_t *)tqp;
 8001974:	f503 72a2 	add.w	r2, r3, #324	; 0x144
  tp->epending  = (eventmask_t)0;
 8001978:	f8c3 414c 	str.w	r4, [r3, #332]	; 0x14c
  REG_INSERT(tp);
 800197c:	f8c3 6128 	str.w	r6, [r3, #296]	; 0x128
  tp->wabase = tdp->wbase;
 8001980:	f8c3 3134 	str.w	r3, [r3, #308]	; 0x134
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8001984:	f8c3 c114 	str.w	ip, [r3, #276]	; 0x114
  tp->name      = name;
 8001988:	f8c3 7130 	str.w	r7, [r3, #304]	; 0x130
  REG_INSERT(tp);
 800198c:	6108      	str	r0, [r1, #16]
  tlp->next = (thread_t *)tlp;
 800198e:	f503 71a0 	add.w	r1, r3, #320	; 0x140
  tqp->next = (thread_t *)tqp;
 8001992:	e9c3 1250 	strd	r1, r2, [r3, #320]	; 0x140
  tqp->prev = (thread_t *)tqp;
 8001996:	f8c3 2148 	str.w	r2, [r3, #328]	; 0x148
 800199a:	6170      	str	r0, [r6, #20]
  chSchWakeupS(tp, MSG_OK);
 800199c:	f7ff f878 	bl	8000a90 <chSchWakeupS.constprop.0>
 80019a0:	f384 8811 	msr	BASEPRI, r4
  tqp->next = (thread_t *)tqp;
 80019a4:	4b37      	ldr	r3, [pc, #220]	; (8001a84 <main+0x444>)

void dspInit(void)
{
    arm_status armStatus;

    memset(&cmsisDsp, 0, sizeof(cmsisDsp));
 80019a6:	4f38      	ldr	r7, [pc, #224]	; (8001a88 <main+0x448>)
          MP45DT02_EXPANDED_BUFFER_SIZE, sizeof(mp45dt02ExpandedBuffer),
          MP45DT02_DECIMATED_BUFFER_SIZE);

    chSemObjectInit(&mp45dt02ProcessingSem, 0);

    pMp45dt02ProcessingThd = chThdCreateStatic(mp45dt02ProcessingThdWA,
 80019a8:	4a38      	ldr	r2, [pc, #224]	; (8001a8c <main+0x44c>)
 80019aa:	4839      	ldr	r0, [pc, #228]	; (8001a90 <main+0x450>)
  sp->cnt = n;
 80019ac:	609c      	str	r4, [r3, #8]
  tqp->prev = (thread_t *)tqp;
 80019ae:	e9c3 3300 	strd	r3, r3, [r3]
 80019b2:	f44f 7114 	mov.w	r1, #592	; 0x250
 80019b6:	f7ff f89b 	bl	8000af0 <chThdCreateStatic.constprop.0>
    memset(&cmsisDsp, 0, sizeof(cmsisDsp));
 80019ba:	4621      	mov	r1, r4
 80019bc:	4638      	mov	r0, r7
 80019be:	f241 420c 	movw	r2, #5132	; 0x140c
 80019c2:	f000 fd1f 	bl	8002404 <memset>
    cmsisDsp.guard = MEMORY_GUARD;
 80019c6:	f241 4108 	movw	r1, #5128	; 0x1408
 80019ca:	4832      	ldr	r0, [pc, #200]	; (8001a94 <main+0x454>)
 80019cc:	5078      	str	r0, [r7, r1]

    /* Assign coefficient pointer */
    S->pCoeffs = pCoeffs;

    /* Clear state buffer and size is always (blockSize + numTaps - 1) */
    memset(pState, 0, (numTaps + (blockSize - 1U)) * sizeof(float32_t));
 80019ce:	f107 030c 	add.w	r3, r7, #12
    S->pCoeffs = pCoeffs;
 80019d2:	4a31      	ldr	r2, [pc, #196]	; (8001a98 <main+0x458>)
 80019d4:	607a      	str	r2, [r7, #4]
    S->numTaps = numTaps;
 80019d6:	f44f 7080 	mov.w	r0, #256	; 0x100
    memset(pState, 0, (numTaps + (blockSize - 1U)) * sizeof(float32_t));
 80019da:	4621      	mov	r1, r4
    S->numTaps = numTaps;
 80019dc:	8078      	strh	r0, [r7, #2]
    memset(pState, 0, (numTaps + (blockSize - 1U)) * sizeof(float32_t));
 80019de:	f241 32fc 	movw	r2, #5116	; 0x13fc
 80019e2:	4618      	mov	r0, r3
 80019e4:	f000 fd0e 	bl	8002404 <memset>
 80019e8:	4603      	mov	r3, r0

    /* Assign state pointer */
    S->pState = pState;
 80019ea:	60bb      	str	r3, [r7, #8]
  tmp->best       = (rtcnt_t)-1;
 80019ec:	482b      	ldr	r0, [pc, #172]	; (8001a9c <main+0x45c>)
    chTMObjectInit(&debugTimings.expansion);
    chTMObjectInit(&debugTimings.callback);
    chTMObjectInit(&debugTimings.totalProcessing);
    chTMObjectInit(&debugTimings.oneSecond);

    memset(&mp45dt02I2SConfig, 0, sizeof(mp45dt02I2SConfig));
 80019ee:	4e2c      	ldr	r6, [pc, #176]	; (8001aa0 <main+0x460>)

    memset(&mp45dt02I2sData, 0, sizeof(mp45dt02I2sData));
 80019f0:	f8df 90c4 	ldr.w	r9, [pc, #196]	; 8001ab8 <main+0x478>
  tmp->n          = (ucnt_t)0;
 80019f4:	60c4      	str	r4, [r0, #12]

    /* Assign Decimation Factor */
    S->M = M;
 80019f6:	2340      	movs	r3, #64	; 0x40
 80019f8:	703b      	strb	r3, [r7, #0]
  tmp->best       = (rtcnt_t)-1;
 80019fa:	f04f 33ff 	mov.w	r3, #4294967295
  tmp->cumulative = (rttime_t)0;
 80019fe:	2200      	movs	r2, #0
  tmp->best       = (rtcnt_t)-1;
 8001a00:	6003      	str	r3, [r0, #0]
 8001a02:	6183      	str	r3, [r0, #24]
 8001a04:	6303      	str	r3, [r0, #48]	; 0x30
 8001a06:	6483      	str	r3, [r0, #72]	; 0x48
 8001a08:	6603      	str	r3, [r0, #96]	; 0x60
  tmp->cumulative = (rttime_t)0;
 8001a0a:	2300      	movs	r3, #0
 8001a0c:	e9c0 2304 	strd	r2, r3, [r0, #16]
 8001a10:	e9c0 230a 	strd	r2, r3, [r0, #40]	; 0x28
 8001a14:	e9c0 2310 	strd	r2, r3, [r0, #64]	; 0x40
 8001a18:	e9c0 2316 	strd	r2, r3, [r0, #88]	; 0x58
 8001a1c:	e04e      	b.n	8001abc <main+0x47c>
 8001a1e:	bf00      	nop
 8001a20:	e000e100 	.word	0xe000e100
 8001a24:	20000c00 	.word	0x20000c00
 8001a28:	40026000 	.word	0x40026000
 8001a2c:	40026400 	.word	0x40026400
 8001a30:	20000c20 	.word	0x20000c20
 8001a34:	00012d1e 	.word	0x00012d1e
 8001a38:	08000601 	.word	0x08000601
 8001a3c:	40011000 	.word	0x40011000
 8001a40:	08000611 	.word	0x08000611
 8001a44:	20000d18 	.word	0x20000d18
 8001a48:	40023800 	.word	0x40023800
 8001a4c:	e0042000 	.word	0xe0042000
 8001a50:	20000f38 	.word	0x20000f38
 8001a54:	20020000 	.word	0x20020000
 8001a58:	20000d90 	.word	0x20000d90
 8001a5c:	080005c1 	.word	0x080005c1
 8001a60:	08000681 	.word	0x08000681
 8001a64:	20000d48 	.word	0x20000d48
 8001a68:	e000ed00 	.word	0xe000ed00
 8001a6c:	05fa0300 	.word	0x05fa0300
 8001a70:	e000edf0 	.word	0xe000edf0
 8001a74:	e0001000 	.word	0xe0001000
 8001a78:	20000dd8 	.word	0x20000dd8
 8001a7c:	08000861 	.word	0x08000861
 8001a80:	080024e0 	.word	0x080024e0
 8001a84:	20003588 	.word	0x20003588
 8001a88:	20000f40 	.word	0x20000f40
 8001a8c:	08000e21 	.word	0x08000e21
 8001a90:	20003598 	.word	0x20003598
 8001a94:	deadbeef 	.word	0xdeadbeef
 8001a98:	20000800 	.word	0x20000800
 8001a9c:	20002350 	.word	0x20002350
 8001aa0:	20003468 	.word	0x20003468
 8001aa4:	20000c9c 	.word	0x20000c9c
 8001aa8:	200023c8 	.word	0x200023c8
 8001aac:	2001c9c0 	.word	0x2001c9c0
 8001ab0:	080025a8 	.word	0x080025a8
 8001ab4:	08000321 	.word	0x08000321
 8001ab8:	2000347c 	.word	0x2000347c
 8001abc:	e9c0 231c 	strd	r2, r3, [r0, #112]	; 0x70
  tmp->last       = (rtcnt_t)0;
 8001ac0:	e9c0 4401 	strd	r4, r4, [r0, #4]
 8001ac4:	e9c0 4407 	strd	r4, r4, [r0, #28]
 8001ac8:	e9c0 440d 	strd	r4, r4, [r0, #52]	; 0x34
 8001acc:	e9c0 4413 	strd	r4, r4, [r0, #76]	; 0x4c
 8001ad0:	e9c0 4419 	strd	r4, r4, [r0, #100]	; 0x64
 8001ad4:	4621      	mov	r1, r4
  tmp->n          = (ucnt_t)0;
 8001ad6:	6244      	str	r4, [r0, #36]	; 0x24
 8001ad8:	63c4      	str	r4, [r0, #60]	; 0x3c
 8001ada:	6544      	str	r4, [r0, #84]	; 0x54
 8001adc:	66c4      	str	r4, [r0, #108]	; 0x6c
    memset(&mp45dt02I2SConfig, 0, sizeof(mp45dt02I2SConfig));
 8001ade:	e9c6 4400 	strd	r4, r4, [r6]
 8001ae2:	e9c6 4402 	strd	r4, r4, [r6, #8]
 8001ae6:	6134      	str	r4, [r6, #16]
    memset(&mp45dt02I2sData, 0, sizeof(mp45dt02I2sData));
 8001ae8:	4648      	mov	r0, r9
 8001aea:	f44f 7286 	mov.w	r2, #268	; 0x10c
 8001aee:	f000 fc89 	bl	8002404 <memset>
    mp45dt02I2sData.guard = MEMORY_GUARD;

    output.guard = MEMORY_GUARD;
 8001af2:	4b43      	ldr	r3, [pc, #268]	; (8001c00 <main+0x5c0>)
    mp45dt02I2sData.guard = MEMORY_GUARD;
 8001af4:	4a43      	ldr	r2, [pc, #268]	; (8001c04 <main+0x5c4>)

    palSetPadMode(MP45DT02_PDM_PORT, MP45DT02_PDM_PAD,
 8001af6:	4844      	ldr	r0, [pc, #272]	; (8001c08 <main+0x5c8>)
    mp45dt02I2sData.guard = MEMORY_GUARD;
 8001af8:	f8c9 2108 	str.w	r2, [r9, #264]	; 0x108
    palSetPadMode(MP45DT02_PDM_PORT, MP45DT02_PDM_PAD,
 8001afc:	2108      	movs	r1, #8
    output.guard = MEMORY_GUARD;
 8001afe:	605a      	str	r2, [r3, #4]
    palSetPadMode(MP45DT02_PDM_PORT, MP45DT02_PDM_PAD,
 8001b00:	f7fe fd16 	bl	8000530 <_pal_lld_setgroupmode.constprop.0>
                  PAL_MODE_ALTERNATE(5)     |
                  PAL_STM32_OTYPE_PUSHPULL  |
                  PAL_STM32_OSPEED_HIGHEST);

    palSetPadMode(MP45DT02_CLK_PORT, MP45DT02_CLK_PAD,
 8001b04:	4841      	ldr	r0, [pc, #260]	; (8001c0c <main+0x5cc>)
 8001b06:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8001b0a:	f7fe fd11 	bl	8000530 <_pal_lld_setgroupmode.constprop.0>
#endif

    mp45dt02I2SConfig.tx_buffer = NULL;
    mp45dt02I2SConfig.rx_buffer = mp45dt02I2sData.buffer;
    mp45dt02I2SConfig.size      = MP45DT02_I2S_BUFFER_SIZE_2B;
    mp45dt02I2SConfig.end_cb    = mp45dt02Cb;
 8001b0e:	4940      	ldr	r1, [pc, #256]	; (8001c10 <main+0x5d0>)

    mp45dt02I2SConfig.i2scfgr   = I2SCFG_MODE_MASTER_RECEIVE    |
 8001b10:	4a40      	ldr	r2, [pc, #256]	; (8001c14 <main+0x5d4>)
    mp45dt02I2SConfig.tx_buffer = NULL;
 8001b12:	6034      	str	r4, [r6, #0]
    mp45dt02I2SConfig.rx_buffer = mp45dt02I2sData.buffer;
 8001b14:	f109 0308 	add.w	r3, r9, #8
 8001b18:	e9c6 3b01 	strd	r3, fp, [r6, #4]
    mp45dt02I2SConfig.i2scfgr   = I2SCFG_MODE_MASTER_RECEIVE    |
 8001b1c:	e9c6 1203 	strd	r1, r2, [r6, #12]
 8001b20:	f38a 8811 	msr	BASEPRI, sl
  if (i2sp->state == I2S_STOP) {
 8001b24:	782b      	ldrb	r3, [r5, #0]
  i2sp->config = config;
 8001b26:	606e      	str	r6, [r5, #4]
 8001b28:	2b01      	cmp	r3, #1
 8001b2a:	d025      	beq.n	8001b78 <main+0x538>
  i2sp->spi->I2SCFGR = i2sp->config->i2scfgr | i2sp->cfg | SPI_I2SCFGR_I2SMOD;
 8001b2c:	89a9      	ldrh	r1, [r5, #12]
 8001b2e:	f9b6 3010 	ldrsh.w	r3, [r6, #16]
  i2sp->spi->I2SPR   = i2sp->config->i2spr;
 8001b32:	68aa      	ldr	r2, [r5, #8]
 8001b34:	f9b6 0012 	ldrsh.w	r0, [r6, #18]
 8001b38:	6210      	str	r0, [r2, #32]
  i2sp->spi->I2SCFGR = i2sp->config->i2scfgr | i2sp->cfg | SPI_I2SCFGR_I2SMOD;
 8001b3a:	430b      	orrs	r3, r1
 8001b3c:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
  i2sp->state = I2S_READY;
 8001b40:	2102      	movs	r1, #2
 8001b42:	61d3      	str	r3, [r2, #28]
 8001b44:	7029      	strb	r1, [r5, #0]
 8001b46:	2400      	movs	r4, #0
 8001b48:	f384 8811 	msr	BASEPRI, r4
 8001b4c:	2320      	movs	r3, #32
 8001b4e:	f383 8811 	msr	BASEPRI, r3
  i2sStartExchangeI(i2sp);
 8001b52:	f7fe fcbd 	bl	80004d0 <i2s_lld_start_exchange.constprop.0>
 8001b56:	2303      	movs	r3, #3
 8001b58:	702b      	strb	r3, [r5, #0]
 8001b5a:	f384 8811 	msr	BASEPRI, r4
  /*


   * Creates the example thread.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
 8001b5e:	4a2e      	ldr	r2, [pc, #184]	; (8001c18 <main+0x5d8>)
 8001b60:	482e      	ldr	r0, [pc, #184]	; (8001c1c <main+0x5dc>)
  /*
   * Normal main() thread activity, in this demo it does nothing except
   * sleeping in a loop and check the button state.
   */
  while (true) {
    if (palReadPad(GPIOA, GPIOA_BUTTON)) {
 8001b62:	4c2f      	ldr	r4, [pc, #188]	; (8001c20 <main+0x5e0>)
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
 8001b64:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8001b68:	f7fe ffc2 	bl	8000af0 <chThdCreateStatic.constprop.0>
    }
    chThdSleepMilliseconds(500);
 8001b6c:	f241 3088 	movw	r0, #5000	; 0x1388
    if (palReadPad(GPIOA, GPIOA_BUTTON)) {
 8001b70:	6923      	ldr	r3, [r4, #16]
    chThdSleepMilliseconds(500);
 8001b72:	f7ff f925 	bl	8000dc0 <chThdSleep>
  while (true) {
 8001b76:	e7f9      	b.n	8001b6c <main+0x52c>
      rccEnableSPI2(true);
 8001b78:	4b2a      	ldr	r3, [pc, #168]	; (8001c24 <main+0x5e4>)
 8001b7a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8001b7c:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8001b80:	641a      	str	r2, [r3, #64]	; 0x40
 8001b82:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8001b84:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8001b88:	661a      	str	r2, [r3, #96]	; 0x60
    return NULL;
  }

  for (i = startid; i <= endid; i++) {
    uint32_t mask = (1U << i);
    if ((dma.allocated_mask & mask) == 0U) {
 8001b8a:	f8d8 2000 	ldr.w	r2, [r8]
 8001b8e:	6e19      	ldr	r1, [r3, #96]	; 0x60
 8001b90:	0711      	lsls	r1, r2, #28
 8001b92:	d506      	bpl.n	8001ba2 <main+0x562>
      i2sp->spi->CR1 = 0;
 8001b94:	68ab      	ldr	r3, [r5, #8]
      i2sp->dmarx = dmaStreamAllocI(STM32_I2S_SPI2_RX_DMA_STREAM,
 8001b96:	612c      	str	r4, [r5, #16]
      i2sp->spi->CR1 = 0;
 8001b98:	2100      	movs	r1, #0
      i2sp->spi->CR2 = SPI_CR2_RXDMAEN;
 8001b9a:	2201      	movs	r2, #1
      i2sp->spi->CR1 = 0;
 8001b9c:	6019      	str	r1, [r3, #0]
      i2sp->spi->CR2 = SPI_CR2_RXDMAEN;
 8001b9e:	605a      	str	r2, [r3, #4]
 8001ba0:	e7c4      	b.n	8001b2c <main+0x4ec>
      const stm32_dma_stream_t *dmastp = STM32_DMA_STREAM(i);

      /* Installs the DMA handler.*/
      dma.streams[i].func  = func;
      dma.streams[i].param = param;
      dma.allocated_mask  |= mask;
 8001ba2:	f042 0208 	orr.w	r2, r2, #8
 8001ba6:	f8c8 2000 	str.w	r2, [r8]

      /* Enabling DMA clocks required by the current streams set.*/
      if ((STM32_DMA1_STREAMS_MASK & mask) != 0U) {
        rccEnableDMA1(true);
 8001baa:	6b1a      	ldr	r2, [r3, #48]	; 0x30
      dma.streams[i].param = param;
 8001bac:	f8c8 5020 	str.w	r5, [r8, #32]
        rccEnableDMA1(true);
 8001bb0:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8001bb4:	631a      	str	r2, [r3, #48]	; 0x30
 8001bb6:	6d19      	ldr	r1, [r3, #80]	; 0x50
        rccEnableDMAMUX(true);
      }
#endif

      /* Putting the stream in a safe state.*/
      dmaStreamDisable(dmastp);
 8001bb8:	4a1b      	ldr	r2, [pc, #108]	; (8001c28 <main+0x5e8>)
        rccEnableDMA1(true);
 8001bba:	f441 1100 	orr.w	r1, r1, #2097152	; 0x200000
 8001bbe:	6519      	str	r1, [r3, #80]	; 0x50
 8001bc0:	6d1b      	ldr	r3, [r3, #80]	; 0x50
      dmaStreamDisable(dmastp);
 8001bc2:	6813      	ldr	r3, [r2, #0]
      dma.streams[i].func  = func;
 8001bc4:	4919      	ldr	r1, [pc, #100]	; (8001c2c <main+0x5ec>)
 8001bc6:	f8c8 101c 	str.w	r1, [r8, #28]
      dmaStreamDisable(dmastp);
 8001bca:	f023 031f 	bic.w	r3, r3, #31
 8001bce:	6013      	str	r3, [r2, #0]
 8001bd0:	4613      	mov	r3, r2
 8001bd2:	681a      	ldr	r2, [r3, #0]
 8001bd4:	f012 0201 	ands.w	r2, r2, #1
 8001bd8:	d1fb      	bne.n	8001bd2 <main+0x592>
 8001bda:	4815      	ldr	r0, [pc, #84]	; (8001c30 <main+0x5f0>)
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001bdc:	4915      	ldr	r1, [pc, #84]	; (8001c34 <main+0x5f4>)
 8001bde:	f04f 6474 	mov.w	r4, #255852544	; 0xf400000
 8001be2:	6004      	str	r4, [r0, #0]
      dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
 8001be4:	601a      	str	r2, [r3, #0]
      dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
 8001be6:	2421      	movs	r4, #33	; 0x21
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001be8:	f44f 4280 	mov.w	r2, #16384	; 0x4000
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001bec:	20a0      	movs	r0, #160	; 0xa0
 8001bee:	615c      	str	r4, [r3, #20]
 8001bf0:	f881 030e 	strb.w	r0, [r1, #782]	; 0x30e
      /* Enables the associated IRQ vector if a callback is defined.*/
      if (func != NULL) {
        nvicEnableVector(dmastp->vector, priority);
      }

      return dmastp;
 8001bf4:	4c10      	ldr	r4, [pc, #64]	; (8001c38 <main+0x5f8>)
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001bf6:	f8c1 2180 	str.w	r2, [r1, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001bfa:	600a      	str	r2, [r1, #0]
 8001bfc:	e7ca      	b.n	8001b94 <main+0x554>
 8001bfe:	bf00      	nop
 8001c00:	2001c7e8 	.word	0x2001c7e8
 8001c04:	deadbeef 	.word	0xdeadbeef
 8001c08:	40020800 	.word	0x40020800
 8001c0c:	40020400 	.word	0x40020400
 8001c10:	080007b1 	.word	0x080007b1
 8001c14:	002a0318 	.word	0x002a0318
 8001c18:	08000de1 	.word	0x08000de1
 8001c1c:	2001c7f0 	.word	0x2001c7f0
 8001c20:	40020000 	.word	0x40020000
 8001c24:	40023800 	.word	0x40023800
 8001c28:	40026058 	.word	0x40026058
 8001c2c:	08000a31 	.word	0x08000a31
 8001c30:	40026008 	.word	0x40026008
 8001c34:	e000e100 	.word	0xe000e100
 8001c38:	0800250c 	.word	0x0800250c
 8001c3c:	00000000 	.word	0x00000000

08001c40 <HardFault_Handler>:
    va_end(ap);*/
}

void HardFault_Handler(void) 
{
    LED_RED_SET();
 8001c40:	4b02      	ldr	r3, [pc, #8]	; (8001c4c <HardFault_Handler+0xc>)
 8001c42:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8001c46:	831a      	strh	r2, [r3, #24]
    while (true);
 8001c48:	e7fe      	b.n	8001c48 <HardFault_Handler+0x8>
 8001c4a:	bf00      	nop
 8001c4c:	40020c00 	.word	0x40020c00

08001c50 <SVC_Handler>:
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8001c50:	f3ef 8309 	mrs	r3, PSP
    FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
 8001c54:	4905      	ldr	r1, [pc, #20]	; (8001c6c <SVC_Handler+0x1c>)
 8001c56:	684a      	ldr	r2, [r1, #4]
 8001c58:	f022 0201 	bic.w	r2, r2, #1
    psp += sizeof (struct port_extctx);
 8001c5c:	3368      	adds	r3, #104	; 0x68
    FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
 8001c5e:	604a      	str	r2, [r1, #4]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8001c60:	f383 8809 	msr	PSP, r3
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8001c64:	2300      	movs	r3, #0
 8001c66:	f383 8811 	msr	BASEPRI, r3
}
 8001c6a:	4770      	bx	lr
 8001c6c:	e000ef30 	.word	0xe000ef30

08001c70 <chThdExit>:
void chThdExit(msg_t msg) {
 8001c70:	b538      	push	{r3, r4, r5, lr}
 8001c72:	2220      	movs	r2, #32
 8001c74:	4603      	mov	r3, r0
 8001c76:	f382 8811 	msr	BASEPRI, r2
  thread_t *tp = currp;
 8001c7a:	4a0f      	ldr	r2, [pc, #60]	; (8001cb8 <chThdExit+0x48>)
 8001c7c:	6994      	ldr	r4, [r2, #24]
  return (bool)(tlp->next != (thread_t *)tlp);
 8001c7e:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  tp->u.exitcode = msg;
 8001c80:	6263      	str	r3, [r4, #36]	; 0x24
  while (list_notempty(&tp->waiting)) {
 8001c82:	f104 0528 	add.w	r5, r4, #40	; 0x28
 8001c86:	42a8      	cmp	r0, r5
 8001c88:	d006      	beq.n	8001c98 <chThdExit+0x28>
  tlp->next = tp->queue.next;
 8001c8a:	6803      	ldr	r3, [r0, #0]
 8001c8c:	62a3      	str	r3, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->waiting));
 8001c8e:	f7fe fd77 	bl	8000780 <chSchReadyI>
  return (bool)(tlp->next != (thread_t *)tlp);
 8001c92:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  while (list_notempty(&tp->waiting)) {
 8001c94:	42a8      	cmp	r0, r5
 8001c96:	d1f8      	bne.n	8001c8a <chThdExit+0x1a>
  if ((tp->refs == (trefs_t)0) &&
 8001c98:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 8001c9c:	b93b      	cbnz	r3, 8001cae <chThdExit+0x3e>
 8001c9e:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
 8001ca2:	079b      	lsls	r3, r3, #30
 8001ca4:	d103      	bne.n	8001cae <chThdExit+0x3e>
    REG_REMOVE(tp);
 8001ca6:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
 8001caa:	6113      	str	r3, [r2, #16]
 8001cac:	615a      	str	r2, [r3, #20]
}
 8001cae:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chSchGoSleepS(CH_STATE_FINAL);
 8001cb2:	200f      	movs	r0, #15
 8001cb4:	f7fe bf54 	b.w	8000b60 <chSchGoSleepS>
 8001cb8:	20000d18 	.word	0x20000d18
 8001cbc:	00000000 	.word	0x00000000

08001cc0 <chSchDoReschedule>:
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
  thread_t *otp = currp;
 8001cc0:	4a0d      	ldr	r2, [pc, #52]	; (8001cf8 <chSchDoReschedule+0x38>)
  thread_t *tp = tqp->next;
 8001cc2:	6810      	ldr	r0, [r2, #0]
 8001cc4:	6991      	ldr	r1, [r2, #24]
  tqp->next             = tp->queue.next;
 8001cc6:	6803      	ldr	r3, [r0, #0]
void chSchDoReschedule(void) {
 8001cc8:	b430      	push	{r4, r5}

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8001cca:	2401      	movs	r4, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 8001ccc:	605a      	str	r2, [r3, #4]
  tp->state = CH_STATE_READY;
 8001cce:	2500      	movs	r5, #0
  currp->state = CH_STATE_CURRENT;
 8001cd0:	f880 4020 	strb.w	r4, [r0, #32]

  /* Handling idle-leave hook.*/
  if (otp->prio == IDLEPRIO) {
 8001cd4:	688c      	ldr	r4, [r1, #8]
  tqp->next             = tp->queue.next;
 8001cd6:	6013      	str	r3, [r2, #0]
  currp = queue_fifo_remove(&ch.rlist.queue);
 8001cd8:	6190      	str	r0, [r2, #24]
  tp->state = CH_STATE_READY;
 8001cda:	f881 5020 	strb.w	r5, [r1, #32]
  cp = (thread_t *)&ch.rlist.queue;
 8001cde:	e000      	b.n	8001ce2 <chSchDoReschedule+0x22>
 8001ce0:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio > tp->prio);
 8001ce2:	689a      	ldr	r2, [r3, #8]
 8001ce4:	4294      	cmp	r4, r2
 8001ce6:	d3fb      	bcc.n	8001ce0 <chSchDoReschedule+0x20>
  tp->queue.prev             = cp->queue.prev;
 8001ce8:	685a      	ldr	r2, [r3, #4]
  otp = chSchReadyAheadI(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
}
 8001cea:	bc30      	pop	{r4, r5}
  tp->queue.prev             = cp->queue.prev;
 8001cec:	e9c1 3200 	strd	r3, r2, [r1]
  tp->queue.prev->queue.next = tp;
 8001cf0:	6011      	str	r1, [r2, #0]
  cp->queue.prev             = tp;
 8001cf2:	6059      	str	r1, [r3, #4]
  chSysSwitch(currp, otp);
 8001cf4:	f7fe bb08 	b.w	8000308 <_port_switch>
 8001cf8:	20000d18 	.word	0x20000d18
 8001cfc:	00000000 	.word	0x00000000

08001d00 <__early_init>:

static void stm32_gpio_init(void) {

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB1(STM32_GPIO_EN_MASK);
 8001d00:	4a7e      	ldr	r2, [pc, #504]	; (8001efc <__early_init+0x1fc>)
  gpiop->OTYPER  = config->otyper;
 8001d02:	487f      	ldr	r0, [pc, #508]	; (8001f00 <__early_init+0x200>)
  rccResetAHB1(STM32_GPIO_EN_MASK);
 8001d04:	6913      	ldr	r3, [r2, #16]
  gpiop->OTYPER  = config->otyper;
 8001d06:	f8df c24c 	ldr.w	ip, [pc, #588]	; 8001f54 <__early_init+0x254>
  rccResetAHB1(STM32_GPIO_EN_MASK);
 8001d0a:	f240 11ff 	movw	r1, #511	; 0x1ff
 8001d0e:	430b      	orrs	r3, r1
/**
 * @brief   Early initialization code.
 * @details GPIO ports and system clocks are initialized before everything
 *          else.
 */
void __early_init(void) {
 8001d10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  rccResetAHB1(STM32_GPIO_EN_MASK);
 8001d14:	6113      	str	r3, [r2, #16]
 8001d16:	6913      	ldr	r3, [r2, #16]
  gpiop->OTYPER  = config->otyper;
 8001d18:	4e7a      	ldr	r6, [pc, #488]	; (8001f04 <__early_init+0x204>)
  gpiop->PUPDR   = config->pupdr;
 8001d1a:	f8df e23c 	ldr.w	lr, [pc, #572]	; 8001f58 <__early_init+0x258>
  gpiop->AFRL    = config->afrl;
 8001d1e:	4f7a      	ldr	r7, [pc, #488]	; (8001f08 <__early_init+0x208>)
  gpiop->OTYPER  = config->otyper;
 8001d20:	4d7a      	ldr	r5, [pc, #488]	; (8001f0c <__early_init+0x20c>)
 8001d22:	4c7b      	ldr	r4, [pc, #492]	; (8001f10 <__early_init+0x210>)
  rccResetAHB1(STM32_GPIO_EN_MASK);
 8001d24:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
 8001d28:	f023 0301 	bic.w	r3, r3, #1
 8001d2c:	6113      	str	r3, [r2, #16]
 8001d2e:	6913      	ldr	r3, [r2, #16]
  rccEnableAHB1(STM32_GPIO_EN_MASK, true);
 8001d30:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8001d32:	430b      	orrs	r3, r1
 8001d34:	6313      	str	r3, [r2, #48]	; 0x30
 8001d36:	6d13      	ldr	r3, [r2, #80]	; 0x50
 8001d38:	430b      	orrs	r3, r1
 8001d3a:	6513      	str	r3, [r2, #80]	; 0x50
  gpiop->OSPEEDR = config->ospeedr;
 8001d3c:	f46f 41a8 	mvn.w	r1, #21504	; 0x5400
  gpiop->OTYPER  = config->otyper;
 8001d40:	2300      	movs	r3, #0
  rccEnableAHB1(STM32_GPIO_EN_MASK, true);
 8001d42:	f8d2 8050 	ldr.w	r8, [r2, #80]	; 0x50
  gpiop->OTYPER  = config->otyper;
 8001d46:	6043      	str	r3, [r0, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001d48:	6081      	str	r1, [r0, #8]
  gpiop->ODR     = config->odr;
 8001d4a:	f64f 71ff 	movw	r1, #65535	; 0xffff
  gpiop->PUPDR   = config->pupdr;
 8001d4e:	f8c0 e00c 	str.w	lr, [r0, #12]
  gpiop->AFRH    = config->afrh;
 8001d52:	f8df 8208 	ldr.w	r8, [pc, #520]	; 8001f5c <__early_init+0x25c>
  gpiop->ODR     = config->odr;
 8001d56:	6141      	str	r1, [r0, #20]
  gpiop->MODER   = config->moder;
 8001d58:	f8df e204 	ldr.w	lr, [pc, #516]	; 8001f60 <__early_init+0x260>
  gpiop->AFRL    = config->afrl;
 8001d5c:	6207      	str	r7, [r0, #32]
  gpiop->OTYPER  = config->otyper;
 8001d5e:	f44f 7710 	mov.w	r7, #576	; 0x240
  gpiop->AFRH    = config->afrh;
 8001d62:	f8c0 8024 	str.w	r8, [r0, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001d66:	f8c0 e000 	str.w	lr, [r0]
  gpiop->OTYPER  = config->otyper;
 8001d6a:	6077      	str	r7, [r6, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001d6c:	f04f 30ff 	mov.w	r0, #4294967295
  gpiop->PUPDR   = config->pupdr;
 8001d70:	f8df e1f0 	ldr.w	lr, [pc, #496]	; 8001f64 <__early_init+0x264>
  gpiop->OSPEEDR = config->ospeedr;
 8001d74:	60b0      	str	r0, [r6, #8]
  gpiop->AFRL    = config->afrl;
 8001d76:	f04f 6780 	mov.w	r7, #67108864	; 0x4000000
  gpiop->PUPDR   = config->pupdr;
 8001d7a:	f8c6 e00c 	str.w	lr, [r6, #12]
  gpiop->ODR     = config->odr;
 8001d7e:	6171      	str	r1, [r6, #20]
  gpiop->AFRH    = config->afrh;
 8001d80:	f04f 0e40 	mov.w	lr, #64	; 0x40
  gpiop->AFRL    = config->afrl;
 8001d84:	6237      	str	r7, [r6, #32]
  gpiop->MODER   = config->moder;
 8001d86:	4f63      	ldr	r7, [pc, #396]	; (8001f14 <__early_init+0x214>)
  gpiop->AFRH    = config->afrh;
 8001d88:	f8c6 e024 	str.w	lr, [r6, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001d8c:	6037      	str	r7, [r6, #0]
  gpiop->PUPDR   = config->pupdr;
 8001d8e:	f106 56a2 	add.w	r6, r6, #339738624	; 0x14400000
 8001d92:	f506 3644 	add.w	r6, r6, #200704	; 0x31000
 8001d96:	f506 76aa 	add.w	r6, r6, #340	; 0x154
  gpiop->OTYPER  = config->otyper;
 8001d9a:	606b      	str	r3, [r5, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001d9c:	60a8      	str	r0, [r5, #8]
  gpiop->PUPDR   = config->pupdr;
 8001d9e:	60ee      	str	r6, [r5, #12]
  gpiop->AFRL    = config->afrl;
 8001da0:	f04f 46c0 	mov.w	r6, #1610612736	; 0x60000000
  gpiop->ODR     = config->odr;
 8001da4:	6169      	str	r1, [r5, #20]
  gpiop->AFRL    = config->afrl;
 8001da6:	622e      	str	r6, [r5, #32]
  gpiop->AFRH    = config->afrh;
 8001da8:	4e5b      	ldr	r6, [pc, #364]	; (8001f18 <__early_init+0x218>)
 8001daa:	626e      	str	r6, [r5, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001dac:	4e5b      	ldr	r6, [pc, #364]	; (8001f1c <__early_init+0x21c>)
 8001dae:	602e      	str	r6, [r5, #0]
  gpiop->PUPDR   = config->pupdr;
 8001db0:	4d5b      	ldr	r5, [pc, #364]	; (8001f20 <__early_init+0x220>)
  gpiop->OTYPER  = config->otyper;
 8001db2:	6063      	str	r3, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001db4:	60a0      	str	r0, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 8001db6:	60e5      	str	r5, [r4, #12]
  gpiop->ODR     = config->odr;
 8001db8:	f640 75ff 	movw	r5, #4095	; 0xfff
 8001dbc:	6165      	str	r5, [r4, #20]
  gpiop->OTYPER  = config->otyper;
 8001dbe:	4f59      	ldr	r7, [pc, #356]	; (8001f24 <__early_init+0x224>)
 8001dc0:	4e59      	ldr	r6, [pc, #356]	; (8001f28 <__early_init+0x228>)
  gpiop->MODER   = config->moder;
 8001dc2:	4d5a      	ldr	r5, [pc, #360]	; (8001f2c <__early_init+0x22c>)
  gpiop->AFRL    = config->afrl;
 8001dc4:	6223      	str	r3, [r4, #32]
  gpiop->AFRH    = config->afrh;
 8001dc6:	6263      	str	r3, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001dc8:	6025      	str	r5, [r4, #0]
  gpiop->OTYPER  = config->otyper;
 8001dca:	f8cc 3004 	str.w	r3, [ip, #4]
 8001dce:	4d58      	ldr	r5, [pc, #352]	; (8001f30 <__early_init+0x230>)
  gpiop->OSPEEDR = config->ospeedr;
 8001dd0:	f8cc 0008 	str.w	r0, [ip, #8]
  gpiop->OTYPER  = config->otyper;
 8001dd4:	f504 54a0 	add.w	r4, r4, #5120	; 0x1400
  gpiop->PUPDR   = config->pupdr;
 8001dd8:	f8cc 300c 	str.w	r3, [ip, #12]
  gpiop->ODR     = config->odr;
 8001ddc:	f8cc 1014 	str.w	r1, [ip, #20]
  gpiop->AFRL    = config->afrl;
 8001de0:	f8cc 3020 	str.w	r3, [ip, #32]
  gpiop->AFRH    = config->afrh;
 8001de4:	f8cc 3024 	str.w	r3, [ip, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001de8:	f8cc e000 	str.w	lr, [ip]
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
#endif

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8001dec:	f5ac 3cd0 	sub.w	ip, ip, #106496	; 0x1a000
  gpiop->OTYPER  = config->otyper;
 8001df0:	607b      	str	r3, [r7, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001df2:	60b8      	str	r0, [r7, #8]
  gpiop->PUPDR   = config->pupdr;
 8001df4:	60fb      	str	r3, [r7, #12]
  gpiop->ODR     = config->odr;
 8001df6:	6179      	str	r1, [r7, #20]
  gpiop->AFRL    = config->afrl;
 8001df8:	623b      	str	r3, [r7, #32]
  gpiop->AFRH    = config->afrh;
 8001dfa:	627b      	str	r3, [r7, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001dfc:	603b      	str	r3, [r7, #0]
  gpiop->OTYPER  = config->otyper;
 8001dfe:	6073      	str	r3, [r6, #4]
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8001e00:	f04f 5780 	mov.w	r7, #268435456	; 0x10000000
  gpiop->OSPEEDR = config->ospeedr;
 8001e04:	60b0      	str	r0, [r6, #8]
  gpiop->PUPDR   = config->pupdr;
 8001e06:	60f3      	str	r3, [r6, #12]
  gpiop->ODR     = config->odr;
 8001e08:	6171      	str	r1, [r6, #20]
  gpiop->AFRL    = config->afrl;
 8001e0a:	6233      	str	r3, [r6, #32]
  gpiop->AFRH    = config->afrh;
 8001e0c:	6273      	str	r3, [r6, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001e0e:	6033      	str	r3, [r6, #0]
  PWR->CR = STM32_VOS;
 8001e10:	f44f 4640 	mov.w	r6, #49152	; 0xc000
  gpiop->OTYPER  = config->otyper;
 8001e14:	606b      	str	r3, [r5, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001e16:	60a8      	str	r0, [r5, #8]
  gpiop->PUPDR   = config->pupdr;
 8001e18:	60eb      	str	r3, [r5, #12]
  gpiop->ODR     = config->odr;
 8001e1a:	6169      	str	r1, [r5, #20]
  gpiop->AFRL    = config->afrl;
 8001e1c:	622b      	str	r3, [r5, #32]
  gpiop->AFRH    = config->afrh;
 8001e1e:	626b      	str	r3, [r5, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001e20:	602b      	str	r3, [r5, #0]
  gpiop->OTYPER  = config->otyper;
 8001e22:	6063      	str	r3, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001e24:	60a0      	str	r0, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 8001e26:	60e3      	str	r3, [r4, #12]
  gpiop->ODR     = config->odr;
 8001e28:	6161      	str	r1, [r4, #20]
  gpiop->AFRL    = config->afrl;
 8001e2a:	6223      	str	r3, [r4, #32]
  gpiop->AFRH    = config->afrh;
 8001e2c:	6263      	str	r3, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001e2e:	6023      	str	r3, [r4, #0]
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8001e30:	6417      	str	r7, [r2, #64]	; 0x40
  PWR->CR = STM32_VOS;
 8001e32:	f8cc 6000 	str.w	r6, [ip]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8001e36:	6813      	ldr	r3, [r2, #0]
 8001e38:	f043 0301 	orr.w	r3, r3, #1
 8001e3c:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8001e3e:	6813      	ldr	r3, [r2, #0]
 8001e40:	079e      	lsls	r6, r3, #30
 8001e42:	d5fc      	bpl.n	8001e3e <__early_init+0x13e>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
 8001e44:	6891      	ldr	r1, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8001e46:	4b2d      	ldr	r3, [pc, #180]	; (8001efc <__early_init+0x1fc>)
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
 8001e48:	f021 0103 	bic.w	r1, r1, #3
 8001e4c:	6091      	str	r1, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8001e4e:	689a      	ldr	r2, [r3, #8]
 8001e50:	f012 020c 	ands.w	r2, r2, #12
 8001e54:	d1fb      	bne.n	8001e4e <__early_init+0x14e>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8001e56:	6818      	ldr	r0, [r3, #0]
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 8001e58:	4928      	ldr	r1, [pc, #160]	; (8001efc <__early_init+0x1fc>)
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8001e5a:	f000 00f9 	and.w	r0, r0, #249	; 0xf9
 8001e5e:	6018      	str	r0, [r3, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8001e60:	609a      	str	r2, [r3, #8]
  RCC->CR |= RCC_CR_HSEON;
 8001e62:	681a      	ldr	r2, [r3, #0]
 8001e64:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8001e68:	601a      	str	r2, [r3, #0]
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 8001e6a:	680b      	ldr	r3, [r1, #0]
 8001e6c:	039d      	lsls	r5, r3, #14
 8001e6e:	d5fc      	bpl.n	8001e6a <__early_init+0x16a>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8001e70:	6f4a      	ldr	r2, [r1, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8001e72:	4b22      	ldr	r3, [pc, #136]	; (8001efc <__early_init+0x1fc>)
  RCC->CSR |= RCC_CSR_LSION;
 8001e74:	f042 0201 	orr.w	r2, r2, #1
 8001e78:	674a      	str	r2, [r1, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8001e7a:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8001e7c:	0794      	lsls	r4, r2, #30
 8001e7e:	d5fc      	bpl.n	8001e7a <__early_init+0x17a>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 8001e80:	4a2c      	ldr	r2, [pc, #176]	; (8001f34 <__early_init+0x234>)
 8001e82:	605a      	str	r2, [r3, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 8001e84:	681a      	ldr	r2, [r3, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8001e86:	492c      	ldr	r1, [pc, #176]	; (8001f38 <__early_init+0x238>)
  RCC->CR |= RCC_CR_PLLON;
 8001e88:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8001e8c:	601a      	str	r2, [r3, #0]
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8001e8e:	684b      	ldr	r3, [r1, #4]
 8001e90:	0458      	lsls	r0, r3, #17
 8001e92:	d5fc      	bpl.n	8001e8e <__early_init+0x18e>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8001e94:	4b19      	ldr	r3, [pc, #100]	; (8001efc <__early_init+0x1fc>)
 8001e96:	681a      	ldr	r2, [r3, #0]
 8001e98:	0192      	lsls	r2, r2, #6
 8001e9a:	d5fc      	bpl.n	8001e96 <__early_init+0x196>
    ;
#endif /* STM32_ACTIVATE_PLLSAI */

  /* Other clock-related settings (dividers, MCO etc).*/
#if !defined(STM32F413xx)
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 8001e9c:	4927      	ldr	r1, [pc, #156]	; (8001f3c <__early_init+0x23c>)

  /* Flash setup.*/
#if !defined(STM32_REMOVE_REVISION_A_FIX)
  /* Some old revisions of F4x MCUs randomly crashes with compiler
     optimizations enabled AND flash caches enabled. */
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 8001e9e:	4a28      	ldr	r2, [pc, #160]	; (8001f40 <__early_init+0x240>)
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 8001ea0:	6099      	str	r1, [r3, #8]
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 8001ea2:	6812      	ldr	r2, [r2, #0]
 8001ea4:	4b27      	ldr	r3, [pc, #156]	; (8001f44 <__early_init+0x244>)
 8001ea6:	429a      	cmp	r2, r3
 8001ea8:	d01e      	beq.n	8001ee8 <__early_init+0x1e8>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 8001eaa:	4b27      	ldr	r3, [pc, #156]	; (8001f48 <__early_init+0x248>)
 8001eac:	f240 7205 	movw	r2, #1797	; 0x705
 8001eb0:	601a      	str	r2, [r3, #0]
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif
  while ((FLASH->ACR & FLASH_ACR_LATENCY_Msk) !=
 8001eb2:	4a25      	ldr	r2, [pc, #148]	; (8001f48 <__early_init+0x248>)
 8001eb4:	6813      	ldr	r3, [r2, #0]
 8001eb6:	f003 030f 	and.w	r3, r3, #15
 8001eba:	2b05      	cmp	r3, #5
 8001ebc:	d1fa      	bne.n	8001eb4 <__early_init+0x1b4>
         (STM32_FLASHBITS & FLASH_ACR_LATENCY_Msk)) {
  }

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 8001ebe:	4b0f      	ldr	r3, [pc, #60]	; (8001efc <__early_init+0x1fc>)
 8001ec0:	689a      	ldr	r2, [r3, #8]
 8001ec2:	f042 0202 	orr.w	r2, r2, #2
 8001ec6:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8001ec8:	689a      	ldr	r2, [r3, #8]
 8001eca:	f002 020c 	and.w	r2, r2, #12
 8001ece:	2a08      	cmp	r2, #8
 8001ed0:	d1fa      	bne.n	8001ec8 <__early_init+0x1c8>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, true);
 8001ed2:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8001ed4:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8001ed8:	645a      	str	r2, [r3, #68]	; 0x44
 8001eda:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 8001edc:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8001ee0:	665a      	str	r2, [r3, #100]	; 0x64
 8001ee2:	6e5b      	ldr	r3, [r3, #100]	; 0x64

  stm32_gpio_init();
  stm32_clock_init();
}
 8001ee4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 8001ee8:	4a18      	ldr	r2, [pc, #96]	; (8001f4c <__early_init+0x24c>)
 8001eea:	4b19      	ldr	r3, [pc, #100]	; (8001f50 <__early_init+0x250>)
 8001eec:	6812      	ldr	r2, [r2, #0]
 8001eee:	429a      	cmp	r2, r3
 8001ef0:	d1db      	bne.n	8001eaa <__early_init+0x1aa>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
 8001ef2:	4b15      	ldr	r3, [pc, #84]	; (8001f48 <__early_init+0x248>)
 8001ef4:	f240 1205 	movw	r2, #261	; 0x105
 8001ef8:	601a      	str	r2, [r3, #0]
 8001efa:	e7da      	b.n	8001eb2 <__early_init+0x1b2>
 8001efc:	40023800 	.word	0x40023800
 8001f00:	40020000 	.word	0x40020000
 8001f04:	40020400 	.word	0x40020400
 8001f08:	55560000 	.word	0x55560000
 8001f0c:	40020800 	.word	0x40020800
 8001f10:	40020c00 	.word	0x40020c00
 8001f14:	00082080 	.word	0x00082080
 8001f18:	00060600 	.word	0x00060600
 8001f1c:	02208001 	.word	0x02208001
 8001f20:	00555055 	.word	0x00555055
 8001f24:	40021400 	.word	0x40021400
 8001f28:	40021800 	.word	0x40021800
 8001f2c:	55000100 	.word	0x55000100
 8001f30:	40021c00 	.word	0x40021c00
 8001f34:	07405408 	.word	0x07405408
 8001f38:	40007000 	.word	0x40007000
 8001f3c:	38889400 	.word	0x38889400
 8001f40:	e0042000 	.word	0xe0042000
 8001f44:	20006411 	.word	0x20006411
 8001f48:	40023c00 	.word	0x40023c00
 8001f4c:	e000ed00 	.word	0xe000ed00
 8001f50:	410fc241 	.word	0x410fc241
 8001f54:	40021000 	.word	0x40021000
 8001f58:	40010054 	.word	0x40010054
 8001f5c:	000aaa00 	.word	0x000aaa00
 8001f60:	2aa0aa00 	.word	0x2aa0aa00
 8001f64:	55514515 	.word	0x55514515
	...

08001f70 <VectorD8>:
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 8001f70:	b508      	push	{r3, lr}
  serve_interrupt(&SD2);
 8001f72:	4803      	ldr	r0, [pc, #12]	; (8001f80 <VectorD8+0x10>)
 8001f74:	f7fe fc7c 	bl	8000870 <serve_interrupt>
}
 8001f78:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8001f7c:	f7fe bb50 	b.w	8000620 <_port_irq_epilogue>
 8001f80:	20000c9c 	.word	0x20000c9c
	...

08001f90 <VectorD4>:
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 8001f90:	b508      	push	{r3, lr}
  serve_interrupt(&SD1);
 8001f92:	4803      	ldr	r0, [pc, #12]	; (8001fa0 <VectorD4+0x10>)
 8001f94:	f7fe fc6c 	bl	8000870 <serve_interrupt>
}
 8001f98:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8001f9c:	f7fe bb40 	b.w	8000620 <_port_irq_epilogue>
 8001fa0:	20000c20 	.word	0x20000c20
	...

08001fb0 <VectorB0>:
void st_lld_serve_interrupt(void) {
#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  uint32_t sr;
  stm32_tim_t *timp = STM32_ST_TIM;

  sr  = timp->SR;
 8001fb0:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8001fb4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  sr  = timp->SR;
 8001fb8:	6903      	ldr	r3, [r0, #16]
  sr &= timp->DIER & STM32_TIM_DIER_IRQ_MASK;
 8001fba:	68c2      	ldr	r2, [r0, #12]
 8001fbc:	4013      	ands	r3, r2
 8001fbe:	b2da      	uxtb	r2, r3
  timp->SR = ~sr;
 8001fc0:	43d2      	mvns	r2, r2

  if ((sr & TIM_SR_CC1IF) != 0U)
 8001fc2:	079b      	lsls	r3, r3, #30
  timp->SR = ~sr;
 8001fc4:	6102      	str	r2, [r0, #16]
  if ((sr & TIM_SR_CC1IF) != 0U)
 8001fc6:	d403      	bmi.n	8001fd0 <VectorB0+0x20>
}
 8001fc8:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  OSAL_IRQ_EPILOGUE();
 8001fcc:	f7fe bb28 	b.w	8000620 <_port_irq_epilogue>
 8001fd0:	2320      	movs	r3, #32
 8001fd2:	f383 8811 	msr	BASEPRI, r3
  virtual_timer_t *vtp;
  systime_t now;
  sysinterval_t delta, nowdelta;

  /* Looping through timers.*/
  vtp = ch.vtlist.next;
 8001fd6:	4d23      	ldr	r5, [pc, #140]	; (8002064 <VectorB0+0xb4>)
  return (systime_t)STM32_ST_TIM->CNT;
 8001fd8:	6a47      	ldr	r7, [r0, #36]	; 0x24
 8001fda:	69eb      	ldr	r3, [r5, #28]
  while (true) {

    /* Getting the system time as reference.*/
    now = chVTGetSystemTimeX();
    nowdelta = chTimeDiffX(ch.vtlist.lasttime, now);
 8001fdc:	6aaa      	ldr	r2, [r5, #40]	; 0x28

    /* The list scan is limited by the timers header having
       "ch.vtlist.vt_delta == (sysinterval_t)-1" which is
       greater than all deltas.*/
    if (nowdelta < vtp->delta) {
 8001fde:	6899      	ldr	r1, [r3, #8]
  return (sysinterval_t)((systime_t)(end - start));
 8001fe0:	1abe      	subs	r6, r7, r2
 8001fe2:	42b1      	cmp	r1, r6
 8001fe4:	bf88      	it	hi
 8001fe6:	f105 091c 	addhi.w	r9, r5, #28
 8001fea:	d825      	bhi.n	8002038 <VectorB0+0x88>
  STM32_ST_TIM->DIER = 0U;
 8001fec:	4604      	mov	r4, r0
 8001fee:	f105 091c 	add.w	r9, r5, #28
      nowdelta -= vtp->delta;

      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
      ch.vtlist.next = vtp->next;
      fn = vtp->func;
      vtp->func = NULL;
 8001ff2:	f04f 0800 	mov.w	r8, #0
 8001ff6:	2720      	movs	r7, #32
 8001ff8:	e000      	b.n	8001ffc <VectorB0+0x4c>
 8001ffa:	6aaa      	ldr	r2, [r5, #40]	; 0x28
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8001ffc:	6818      	ldr	r0, [r3, #0]
      ch.vtlist.lasttime += vtp->delta;
 8001ffe:	440a      	add	r2, r1

      /* If the list becomes empty then the timer is stopped.*/
      if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8002000:	4548      	cmp	r0, r9
      ch.vtlist.lasttime += vtp->delta;
 8002002:	62aa      	str	r2, [r5, #40]	; 0x28
      nowdelta -= vtp->delta;
 8002004:	eba6 0601 	sub.w	r6, r6, r1
      fn = vtp->func;
 8002008:	68da      	ldr	r2, [r3, #12]
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 800200a:	f8c0 9004 	str.w	r9, [r0, #4]
      ch.vtlist.next = vtp->next;
 800200e:	61e8      	str	r0, [r5, #28]
      vtp->func = NULL;
 8002010:	f8c3 800c 	str.w	r8, [r3, #12]
 8002014:	bf08      	it	eq
 8002016:	f8c4 800c 	streq.w	r8, [r4, #12]
 800201a:	f388 8811 	msr	BASEPRI, r8
        port_timer_stop_alarm();
      }

      /* The callback is invoked outside the kernel critical zone.*/
      chSysUnlockFromISR();
      fn(vtp->par);
 800201e:	6918      	ldr	r0, [r3, #16]
 8002020:	4790      	blx	r2
 8002022:	f387 8811 	msr	BASEPRI, r7
      chSysLockFromISR();

      /* Next element in the list.*/
      vtp = ch.vtlist.next;
 8002026:	69eb      	ldr	r3, [r5, #28]
    }
    while (vtp->delta <= nowdelta);
 8002028:	6899      	ldr	r1, [r3, #8]
 800202a:	428e      	cmp	r6, r1
 800202c:	d2e5      	bcs.n	8001ffa <VectorB0+0x4a>
  return (systime_t)STM32_ST_TIM->CNT;
 800202e:	6a67      	ldr	r7, [r4, #36]	; 0x24
    nowdelta = chTimeDiffX(ch.vtlist.lasttime, now);
 8002030:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 8002032:	1abe      	subs	r6, r7, r2
    if (nowdelta < vtp->delta) {
 8002034:	428e      	cmp	r6, r1
 8002036:	d2de      	bcs.n	8001ff6 <VectorB0+0x46>
  }

  /* If the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8002038:	454b      	cmp	r3, r9
 800203a:	d00b      	beq.n	8002054 <VectorB0+0xa4>
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  ch.vtlist.lasttime += nowdelta;
  ch.vtlist.next->delta -= nowdelta;
 800203c:	6899      	ldr	r1, [r3, #8]
  ch.vtlist.lasttime += nowdelta;
 800203e:	62af      	str	r7, [r5, #40]	; 0x28
  ch.vtlist.next->delta -= nowdelta;
 8002040:	1bc9      	subs	r1, r1, r7
 8002042:	440a      	add	r2, r1
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8002044:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
  return systime + (systime_t)interval;
 8002048:	2a02      	cmp	r2, #2
 800204a:	bf2c      	ite	cs
 800204c:	18bf      	addcs	r7, r7, r2
 800204e:	3702      	addcc	r7, #2
 8002050:	609a      	str	r2, [r3, #8]
 8002052:	634f      	str	r7, [r1, #52]	; 0x34
 8002054:	2300      	movs	r3, #0
 8002056:	f383 8811 	msr	BASEPRI, r3
}
 800205a:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  OSAL_IRQ_EPILOGUE();
 800205e:	f7fe badf 	b.w	8000620 <_port_irq_epilogue>
 8002062:	bf00      	nop
 8002064:	20000d18 	.word	0x20000d18
	...

08002070 <Vector158>:
  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8002070:	4b08      	ldr	r3, [pc, #32]	; (8002094 <Vector158+0x24>)
  if (dma.streams[15].func)
 8002072:	4809      	ldr	r0, [pc, #36]	; (8002098 <Vector158+0x28>)
  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8002074:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[15].func)
 8002076:	6fc2      	ldr	r2, [r0, #124]	; 0x7c
  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8002078:	0d89      	lsrs	r1, r1, #22
 800207a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
 800207e:	b510      	push	{r4, lr}
  DMA2->HIFCR = flags << 22U;
 8002080:	058c      	lsls	r4, r1, #22
 8002082:	60dc      	str	r4, [r3, #12]
  if (dma.streams[15].func)
 8002084:	b112      	cbz	r2, 800208c <Vector158+0x1c>
    dma.streams[15].func(dma.streams[15].param, flags);
 8002086:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
 800208a:	4790      	blx	r2
}
 800208c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8002090:	f7fe bac6 	b.w	8000620 <_port_irq_epilogue>
 8002094:	40026400 	.word	0x40026400
 8002098:	200023e4 	.word	0x200023e4
 800209c:	00000000 	.word	0x00000000

080020a0 <Vector154>:
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 80020a0:	4b08      	ldr	r3, [pc, #32]	; (80020c4 <Vector154+0x24>)
  if (dma.streams[14].func)
 80020a2:	4809      	ldr	r0, [pc, #36]	; (80020c8 <Vector154+0x28>)
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 80020a4:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[14].func)
 80020a6:	6f42      	ldr	r2, [r0, #116]	; 0x74
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 80020a8:	0c09      	lsrs	r1, r1, #16
 80020aa:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
 80020ae:	b510      	push	{r4, lr}
  DMA2->HIFCR = flags << 16U;
 80020b0:	040c      	lsls	r4, r1, #16
 80020b2:	60dc      	str	r4, [r3, #12]
  if (dma.streams[14].func)
 80020b4:	b10a      	cbz	r2, 80020ba <Vector154+0x1a>
    dma.streams[14].func(dma.streams[14].param, flags);
 80020b6:	6f80      	ldr	r0, [r0, #120]	; 0x78
 80020b8:	4790      	blx	r2
}
 80020ba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 80020be:	f7fe baaf 	b.w	8000620 <_port_irq_epilogue>
 80020c2:	bf00      	nop
 80020c4:	40026400 	.word	0x40026400
 80020c8:	200023e4 	.word	0x200023e4
 80020cc:	00000000 	.word	0x00000000

080020d0 <Vector150>:
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 80020d0:	4b08      	ldr	r3, [pc, #32]	; (80020f4 <Vector150+0x24>)
  if (dma.streams[13].func)
 80020d2:	4809      	ldr	r0, [pc, #36]	; (80020f8 <Vector150+0x28>)
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 80020d4:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[13].func)
 80020d6:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 80020d8:	0989      	lsrs	r1, r1, #6
 80020da:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 80020de:	b510      	push	{r4, lr}
  DMA2->HIFCR = flags << 6U;
 80020e0:	018c      	lsls	r4, r1, #6
 80020e2:	60dc      	str	r4, [r3, #12]
  if (dma.streams[13].func)
 80020e4:	b10a      	cbz	r2, 80020ea <Vector150+0x1a>
    dma.streams[13].func(dma.streams[13].param, flags);
 80020e6:	6f00      	ldr	r0, [r0, #112]	; 0x70
 80020e8:	4790      	blx	r2
}
 80020ea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 80020ee:	f7fe ba97 	b.w	8000620 <_port_irq_epilogue>
 80020f2:	bf00      	nop
 80020f4:	40026400 	.word	0x40026400
 80020f8:	200023e4 	.word	0x200023e4
 80020fc:	00000000 	.word	0x00000000

08002100 <Vector130>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 8002100:	b508      	push	{r3, lr}
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8002102:	4b07      	ldr	r3, [pc, #28]	; (8002120 <Vector130+0x20>)
  if (dma.streams[12].func)
 8002104:	4807      	ldr	r0, [pc, #28]	; (8002124 <Vector130+0x24>)
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8002106:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[12].func)
 8002108:	6e42      	ldr	r2, [r0, #100]	; 0x64
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 800210a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 0U;
 800210e:	60d9      	str	r1, [r3, #12]
  if (dma.streams[12].func)
 8002110:	b10a      	cbz	r2, 8002116 <Vector130+0x16>
    dma.streams[12].func(dma.streams[12].param, flags);
 8002112:	6e80      	ldr	r0, [r0, #104]	; 0x68
 8002114:	4790      	blx	r2
}
 8002116:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 800211a:	f7fe ba81 	b.w	8000620 <_port_irq_epilogue>
 800211e:	bf00      	nop
 8002120:	40026400 	.word	0x40026400
 8002124:	200023e4 	.word	0x200023e4
	...

08002130 <Vector12C>:
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8002130:	4b08      	ldr	r3, [pc, #32]	; (8002154 <Vector12C+0x24>)
  if (dma.streams[11].func)
 8002132:	4809      	ldr	r0, [pc, #36]	; (8002158 <Vector12C+0x28>)
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8002134:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[11].func)
 8002136:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8002138:	0d89      	lsrs	r1, r1, #22
 800213a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 800213e:	b510      	push	{r4, lr}
  DMA2->LIFCR = flags << 22U;
 8002140:	058c      	lsls	r4, r1, #22
 8002142:	609c      	str	r4, [r3, #8]
  if (dma.streams[11].func)
 8002144:	b10a      	cbz	r2, 800214a <Vector12C+0x1a>
    dma.streams[11].func(dma.streams[11].param, flags);
 8002146:	6e00      	ldr	r0, [r0, #96]	; 0x60
 8002148:	4790      	blx	r2
}
 800214a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 800214e:	f7fe ba67 	b.w	8000620 <_port_irq_epilogue>
 8002152:	bf00      	nop
 8002154:	40026400 	.word	0x40026400
 8002158:	200023e4 	.word	0x200023e4
 800215c:	00000000 	.word	0x00000000

08002160 <Vector128>:
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8002160:	4b08      	ldr	r3, [pc, #32]	; (8002184 <Vector128+0x24>)
  if (dma.streams[10].func)
 8002162:	4809      	ldr	r0, [pc, #36]	; (8002188 <Vector128+0x28>)
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8002164:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[10].func)
 8002166:	6d42      	ldr	r2, [r0, #84]	; 0x54
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8002168:	0c09      	lsrs	r1, r1, #16
 800216a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 800216e:	b510      	push	{r4, lr}
  DMA2->LIFCR = flags << 16U;
 8002170:	040c      	lsls	r4, r1, #16
 8002172:	609c      	str	r4, [r3, #8]
  if (dma.streams[10].func)
 8002174:	b10a      	cbz	r2, 800217a <Vector128+0x1a>
    dma.streams[10].func(dma.streams[10].param, flags);
 8002176:	6d80      	ldr	r0, [r0, #88]	; 0x58
 8002178:	4790      	blx	r2
}
 800217a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 800217e:	f7fe ba4f 	b.w	8000620 <_port_irq_epilogue>
 8002182:	bf00      	nop
 8002184:	40026400 	.word	0x40026400
 8002188:	200023e4 	.word	0x200023e4
 800218c:	00000000 	.word	0x00000000

08002190 <Vector124>:
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8002190:	4b08      	ldr	r3, [pc, #32]	; (80021b4 <Vector124+0x24>)
  if (dma.streams[9].func)
 8002192:	4809      	ldr	r0, [pc, #36]	; (80021b8 <Vector124+0x28>)
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8002194:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[9].func)
 8002196:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8002198:	0989      	lsrs	r1, r1, #6
 800219a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 800219e:	b510      	push	{r4, lr}
  DMA2->LIFCR = flags << 6U;
 80021a0:	018c      	lsls	r4, r1, #6
 80021a2:	609c      	str	r4, [r3, #8]
  if (dma.streams[9].func)
 80021a4:	b10a      	cbz	r2, 80021aa <Vector124+0x1a>
    dma.streams[9].func(dma.streams[9].param, flags);
 80021a6:	6d00      	ldr	r0, [r0, #80]	; 0x50
 80021a8:	4790      	blx	r2
}
 80021aa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 80021ae:	f7fe ba37 	b.w	8000620 <_port_irq_epilogue>
 80021b2:	bf00      	nop
 80021b4:	40026400 	.word	0x40026400
 80021b8:	200023e4 	.word	0x200023e4
 80021bc:	00000000 	.word	0x00000000

080021c0 <Vector120>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
 80021c0:	b508      	push	{r3, lr}
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 80021c2:	4b07      	ldr	r3, [pc, #28]	; (80021e0 <Vector120+0x20>)
  if (dma.streams[8].func)
 80021c4:	4807      	ldr	r0, [pc, #28]	; (80021e4 <Vector120+0x24>)
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 80021c6:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[8].func)
 80021c8:	6c42      	ldr	r2, [r0, #68]	; 0x44
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 80021ca:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 0U;
 80021ce:	6099      	str	r1, [r3, #8]
  if (dma.streams[8].func)
 80021d0:	b10a      	cbz	r2, 80021d6 <Vector120+0x16>
    dma.streams[8].func(dma.streams[8].param, flags);
 80021d2:	6c80      	ldr	r0, [r0, #72]	; 0x48
 80021d4:	4790      	blx	r2
}
 80021d6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 80021da:	f7fe ba21 	b.w	8000620 <_port_irq_epilogue>
 80021de:	bf00      	nop
 80021e0:	40026400 	.word	0x40026400
 80021e4:	200023e4 	.word	0x200023e4
	...

080021f0 <VectorFC>:
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 80021f0:	4b08      	ldr	r3, [pc, #32]	; (8002214 <VectorFC+0x24>)
  if (dma.streams[7].func)
 80021f2:	4809      	ldr	r0, [pc, #36]	; (8002218 <VectorFC+0x28>)
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 80021f4:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[7].func)
 80021f6:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 80021f8:	0d89      	lsrs	r1, r1, #22
 80021fa:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 80021fe:	b510      	push	{r4, lr}
  DMA1->HIFCR = flags << 22U;
 8002200:	058c      	lsls	r4, r1, #22
 8002202:	60dc      	str	r4, [r3, #12]
  if (dma.streams[7].func)
 8002204:	b10a      	cbz	r2, 800220a <VectorFC+0x1a>
    dma.streams[7].func(dma.streams[7].param, flags);
 8002206:	6c00      	ldr	r0, [r0, #64]	; 0x40
 8002208:	4790      	blx	r2
}
 800220a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 800220e:	f7fe ba07 	b.w	8000620 <_port_irq_epilogue>
 8002212:	bf00      	nop
 8002214:	40026000 	.word	0x40026000
 8002218:	200023e4 	.word	0x200023e4
 800221c:	00000000 	.word	0x00000000

08002220 <Vector84>:
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8002220:	4b08      	ldr	r3, [pc, #32]	; (8002244 <Vector84+0x24>)
  if (dma.streams[6].func)
 8002222:	4809      	ldr	r0, [pc, #36]	; (8002248 <Vector84+0x28>)
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8002224:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[6].func)
 8002226:	6b42      	ldr	r2, [r0, #52]	; 0x34
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8002228:	0c09      	lsrs	r1, r1, #16
 800222a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 800222e:	b510      	push	{r4, lr}
  DMA1->HIFCR = flags << 16U;
 8002230:	040c      	lsls	r4, r1, #16
 8002232:	60dc      	str	r4, [r3, #12]
  if (dma.streams[6].func)
 8002234:	b10a      	cbz	r2, 800223a <Vector84+0x1a>
    dma.streams[6].func(dma.streams[6].param, flags);
 8002236:	6b80      	ldr	r0, [r0, #56]	; 0x38
 8002238:	4790      	blx	r2
}
 800223a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 800223e:	f7fe b9ef 	b.w	8000620 <_port_irq_epilogue>
 8002242:	bf00      	nop
 8002244:	40026000 	.word	0x40026000
 8002248:	200023e4 	.word	0x200023e4
 800224c:	00000000 	.word	0x00000000

08002250 <Vector80>:
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8002250:	4b08      	ldr	r3, [pc, #32]	; (8002274 <Vector80+0x24>)
  if (dma.streams[5].func)
 8002252:	4809      	ldr	r0, [pc, #36]	; (8002278 <Vector80+0x28>)
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8002254:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[5].func)
 8002256:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8002258:	0989      	lsrs	r1, r1, #6
 800225a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 800225e:	b510      	push	{r4, lr}
  DMA1->HIFCR = flags << 6U;
 8002260:	018c      	lsls	r4, r1, #6
 8002262:	60dc      	str	r4, [r3, #12]
  if (dma.streams[5].func)
 8002264:	b10a      	cbz	r2, 800226a <Vector80+0x1a>
    dma.streams[5].func(dma.streams[5].param, flags);
 8002266:	6b00      	ldr	r0, [r0, #48]	; 0x30
 8002268:	4790      	blx	r2
}
 800226a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 800226e:	f7fe b9d7 	b.w	8000620 <_port_irq_epilogue>
 8002272:	bf00      	nop
 8002274:	40026000 	.word	0x40026000
 8002278:	200023e4 	.word	0x200023e4
 800227c:	00000000 	.word	0x00000000

08002280 <Vector7C>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8002280:	b508      	push	{r3, lr}
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8002282:	4b07      	ldr	r3, [pc, #28]	; (80022a0 <Vector7C+0x20>)
  if (dma.streams[4].func)
 8002284:	4807      	ldr	r0, [pc, #28]	; (80022a4 <Vector7C+0x24>)
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8002286:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[4].func)
 8002288:	6a42      	ldr	r2, [r0, #36]	; 0x24
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 800228a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 0U;
 800228e:	60d9      	str	r1, [r3, #12]
  if (dma.streams[4].func)
 8002290:	b10a      	cbz	r2, 8002296 <Vector7C+0x16>
    dma.streams[4].func(dma.streams[4].param, flags);
 8002292:	6a80      	ldr	r0, [r0, #40]	; 0x28
 8002294:	4790      	blx	r2
}
 8002296:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 800229a:	f7fe b9c1 	b.w	8000620 <_port_irq_epilogue>
 800229e:	bf00      	nop
 80022a0:	40026000 	.word	0x40026000
 80022a4:	200023e4 	.word	0x200023e4
	...

080022b0 <Vector78>:
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 80022b0:	4b08      	ldr	r3, [pc, #32]	; (80022d4 <Vector78+0x24>)
  if (dma.streams[3].func)
 80022b2:	4809      	ldr	r0, [pc, #36]	; (80022d8 <Vector78+0x28>)
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 80022b4:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[3].func)
 80022b6:	69c2      	ldr	r2, [r0, #28]
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 80022b8:	0d89      	lsrs	r1, r1, #22
 80022ba:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 80022be:	b510      	push	{r4, lr}
  DMA1->LIFCR = flags << 22U;
 80022c0:	058c      	lsls	r4, r1, #22
 80022c2:	609c      	str	r4, [r3, #8]
  if (dma.streams[3].func)
 80022c4:	b10a      	cbz	r2, 80022ca <Vector78+0x1a>
    dma.streams[3].func(dma.streams[3].param, flags);
 80022c6:	6a00      	ldr	r0, [r0, #32]
 80022c8:	4790      	blx	r2
}
 80022ca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 80022ce:	f7fe b9a7 	b.w	8000620 <_port_irq_epilogue>
 80022d2:	bf00      	nop
 80022d4:	40026000 	.word	0x40026000
 80022d8:	200023e4 	.word	0x200023e4
 80022dc:	00000000 	.word	0x00000000

080022e0 <Vector74>:
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 80022e0:	4b08      	ldr	r3, [pc, #32]	; (8002304 <Vector74+0x24>)
  if (dma.streams[2].func)
 80022e2:	4809      	ldr	r0, [pc, #36]	; (8002308 <Vector74+0x28>)
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 80022e4:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[2].func)
 80022e6:	6942      	ldr	r2, [r0, #20]
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 80022e8:	0c09      	lsrs	r1, r1, #16
 80022ea:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 80022ee:	b510      	push	{r4, lr}
  DMA1->LIFCR = flags << 16U;
 80022f0:	040c      	lsls	r4, r1, #16
 80022f2:	609c      	str	r4, [r3, #8]
  if (dma.streams[2].func)
 80022f4:	b10a      	cbz	r2, 80022fa <Vector74+0x1a>
    dma.streams[2].func(dma.streams[2].param, flags);
 80022f6:	6980      	ldr	r0, [r0, #24]
 80022f8:	4790      	blx	r2
}
 80022fa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 80022fe:	f7fe b98f 	b.w	8000620 <_port_irq_epilogue>
 8002302:	bf00      	nop
 8002304:	40026000 	.word	0x40026000
 8002308:	200023e4 	.word	0x200023e4
 800230c:	00000000 	.word	0x00000000

08002310 <Vector70>:
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8002310:	4b08      	ldr	r3, [pc, #32]	; (8002334 <Vector70+0x24>)
  if (dma.streams[1].func)
 8002312:	4809      	ldr	r0, [pc, #36]	; (8002338 <Vector70+0x28>)
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8002314:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[1].func)
 8002316:	68c2      	ldr	r2, [r0, #12]
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8002318:	0989      	lsrs	r1, r1, #6
 800231a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 800231e:	b510      	push	{r4, lr}
  DMA1->LIFCR = flags << 6U;
 8002320:	018c      	lsls	r4, r1, #6
 8002322:	609c      	str	r4, [r3, #8]
  if (dma.streams[1].func)
 8002324:	b10a      	cbz	r2, 800232a <Vector70+0x1a>
    dma.streams[1].func(dma.streams[1].param, flags);
 8002326:	6900      	ldr	r0, [r0, #16]
 8002328:	4790      	blx	r2
}
 800232a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 800232e:	f7fe b977 	b.w	8000620 <_port_irq_epilogue>
 8002332:	bf00      	nop
 8002334:	40026000 	.word	0x40026000
 8002338:	200023e4 	.word	0x200023e4
 800233c:	00000000 	.word	0x00000000

08002340 <Vector6C>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
 8002340:	b508      	push	{r3, lr}
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8002342:	4b07      	ldr	r3, [pc, #28]	; (8002360 <Vector6C+0x20>)
  if (dma.streams[0].func)
 8002344:	4807      	ldr	r0, [pc, #28]	; (8002364 <Vector6C+0x24>)
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8002346:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[0].func)
 8002348:	6842      	ldr	r2, [r0, #4]
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 800234a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 0U;
 800234e:	6099      	str	r1, [r3, #8]
  if (dma.streams[0].func)
 8002350:	b10a      	cbz	r2, 8002356 <Vector6C+0x16>
    dma.streams[0].func(dma.streams[0].param, flags);
 8002352:	6880      	ldr	r0, [r0, #8]
 8002354:	4790      	blx	r2
}
 8002356:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 800235a:	f7fe b961 	b.w	8000620 <_port_irq_epilogue>
 800235e:	bf00      	nop
 8002360:	40026000 	.word	0x40026000
 8002364:	200023e4 	.word	0x200023e4
	...

08002370 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8002370:	b4f0      	push	{r4, r5, r6, r7}
 8002372:	4f14      	ldr	r7, [pc, #80]	; (80023c4 <__init_ram_areas+0x54>)
 8002374:	4d14      	ldr	r5, [pc, #80]	; (80023c8 <__init_ram_areas+0x58>)
 8002376:	4815      	ldr	r0, [pc, #84]	; (80023cc <__init_ram_areas+0x5c>)
 8002378:	4b15      	ldr	r3, [pc, #84]	; (80023d0 <__init_ram_areas+0x60>)
 800237a:	4916      	ldr	r1, [pc, #88]	; (80023d4 <__init_ram_areas+0x64>)
 800237c:	f107 0c70 	add.w	ip, r7, #112	; 0x70
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8002380:	2600      	movs	r6, #0
    while (p < rap->clear_area) {
 8002382:	4298      	cmp	r0, r3
 8002384:	d911      	bls.n	80023aa <__init_ram_areas+0x3a>
 8002386:	3904      	subs	r1, #4
 8002388:	461a      	mov	r2, r3
      *p = *tp;
 800238a:	f851 4f04 	ldr.w	r4, [r1, #4]!
 800238e:	f842 4b04 	str.w	r4, [r2], #4
    while (p < rap->clear_area) {
 8002392:	4290      	cmp	r0, r2
 8002394:	d8f9      	bhi.n	800238a <__init_ram_areas+0x1a>
 8002396:	1e42      	subs	r2, r0, #1
 8002398:	1ad2      	subs	r2, r2, r3
 800239a:	f022 0203 	bic.w	r2, r2, #3
 800239e:	3204      	adds	r2, #4
 80023a0:	4413      	add	r3, r2
    while (p < rap->no_init_area) {
 80023a2:	429d      	cmp	r5, r3
 80023a4:	d903      	bls.n	80023ae <__init_ram_areas+0x3e>
      *p = 0;
 80023a6:	f843 6b04 	str.w	r6, [r3], #4
    while (p < rap->no_init_area) {
 80023aa:	429d      	cmp	r5, r3
 80023ac:	d8fb      	bhi.n	80023a6 <__init_ram_areas+0x36>
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 80023ae:	4567      	cmp	r7, ip
 80023b0:	d005      	beq.n	80023be <__init_ram_areas+0x4e>
 80023b2:	e9d7 1304 	ldrd	r1, r3, [r7, #16]
 80023b6:	e9d7 0506 	ldrd	r0, r5, [r7, #24]
 80023ba:	3710      	adds	r7, #16
 80023bc:	e7e1      	b.n	8002382 <__init_ram_areas+0x12>
#endif
}
 80023be:	bcf0      	pop	{r4, r5, r6, r7}
 80023c0:	4770      	bx	lr
 80023c2:	bf00      	nop
 80023c4:	080025c0 	.word	0x080025c0
 80023c8:	2001c9c0 	.word	0x2001c9c0
 80023cc:	2001c9c0 	.word	0x2001c9c0
 80023d0:	2001c9c0 	.word	0x2001c9c0
 80023d4:	08002a68 	.word	0x08002a68
	...

080023e0 <__default_exit>:
  while (true) {
 80023e0:	e7fe      	b.n	80023e0 <__default_exit>
 80023e2:	bf00      	nop
	...

080023f0 <__late_init>:
 80023f0:	4770      	bx	lr
 80023f2:	bf00      	nop
	...

08002400 <__core_init>:
}
 8002400:	4770      	bx	lr
 8002402:	bf00      	nop

08002404 <memset>:
 8002404:	b4f0      	push	{r4, r5, r6, r7}
 8002406:	0786      	lsls	r6, r0, #30
 8002408:	d046      	beq.n	8002498 <memset+0x94>
 800240a:	1e54      	subs	r4, r2, #1
 800240c:	2a00      	cmp	r2, #0
 800240e:	d03c      	beq.n	800248a <memset+0x86>
 8002410:	b2ca      	uxtb	r2, r1
 8002412:	4603      	mov	r3, r0
 8002414:	e001      	b.n	800241a <memset+0x16>
 8002416:	3c01      	subs	r4, #1
 8002418:	d337      	bcc.n	800248a <memset+0x86>
 800241a:	f803 2b01 	strb.w	r2, [r3], #1
 800241e:	079d      	lsls	r5, r3, #30
 8002420:	d1f9      	bne.n	8002416 <memset+0x12>
 8002422:	2c03      	cmp	r4, #3
 8002424:	d92a      	bls.n	800247c <memset+0x78>
 8002426:	b2cd      	uxtb	r5, r1
 8002428:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 800242c:	2c0f      	cmp	r4, #15
 800242e:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 8002432:	d934      	bls.n	800249e <memset+0x9a>
 8002434:	f1a4 0210 	sub.w	r2, r4, #16
 8002438:	f022 0c0f 	bic.w	ip, r2, #15
 800243c:	f103 0720 	add.w	r7, r3, #32
 8002440:	0916      	lsrs	r6, r2, #4
 8002442:	4467      	add	r7, ip
 8002444:	f103 0210 	add.w	r2, r3, #16
 8002448:	e942 5504 	strd	r5, r5, [r2, #-16]
 800244c:	e942 5502 	strd	r5, r5, [r2, #-8]
 8002450:	3210      	adds	r2, #16
 8002452:	42ba      	cmp	r2, r7
 8002454:	d1f8      	bne.n	8002448 <memset+0x44>
 8002456:	1c72      	adds	r2, r6, #1
 8002458:	f014 0f0c 	tst.w	r4, #12
 800245c:	eb03 1202 	add.w	r2, r3, r2, lsl #4
 8002460:	f004 060f 	and.w	r6, r4, #15
 8002464:	d013      	beq.n	800248e <memset+0x8a>
 8002466:	1f33      	subs	r3, r6, #4
 8002468:	f023 0303 	bic.w	r3, r3, #3
 800246c:	3304      	adds	r3, #4
 800246e:	4413      	add	r3, r2
 8002470:	f842 5b04 	str.w	r5, [r2], #4
 8002474:	4293      	cmp	r3, r2
 8002476:	d1fb      	bne.n	8002470 <memset+0x6c>
 8002478:	f006 0403 	and.w	r4, r6, #3
 800247c:	b12c      	cbz	r4, 800248a <memset+0x86>
 800247e:	b2ca      	uxtb	r2, r1
 8002480:	441c      	add	r4, r3
 8002482:	f803 2b01 	strb.w	r2, [r3], #1
 8002486:	429c      	cmp	r4, r3
 8002488:	d1fb      	bne.n	8002482 <memset+0x7e>
 800248a:	bcf0      	pop	{r4, r5, r6, r7}
 800248c:	4770      	bx	lr
 800248e:	4634      	mov	r4, r6
 8002490:	4613      	mov	r3, r2
 8002492:	2c00      	cmp	r4, #0
 8002494:	d1f3      	bne.n	800247e <memset+0x7a>
 8002496:	e7f8      	b.n	800248a <memset+0x86>
 8002498:	4614      	mov	r4, r2
 800249a:	4603      	mov	r3, r0
 800249c:	e7c1      	b.n	8002422 <memset+0x1e>
 800249e:	461a      	mov	r2, r3
 80024a0:	4626      	mov	r6, r4
 80024a2:	e7e0      	b.n	8002466 <memset+0x62>
